<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林定益想去NASA捡垃圾</title>
  
  <subtitle>Stay hungry,Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://deflin.github.io/"/>
  <updated>2018-06-05T14:26:24.119Z</updated>
  <id>https://deflin.github.io/</id>
  
  <author>
    <name>Def Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>可变参数函数用法</title>
    <link href="https://deflin.github.io/2018/06/05/%E5%9F%BA%E4%BA%8ECC3200%E5%AE%9E%E7%8E%B0WiFi%20Direct/"/>
    <id>https://deflin.github.io/2018/06/05/基于CC3200实现WiFi Direct/</id>
    <published>2018-06-05T14:18:25.303Z</published>
    <updated>2018-06-05T14:26:24.119Z</updated>
    
    <content type="html"><![CDATA[<p>#遇到的问题与解决</p><p>没接触过这类板子，有点陌生，不要紧，一步一步来。<br>    问题一：<br>    1.烧写了官方的SDK，按照提示，通过WiFi直连连接到了手机，但是失败概率很高，使用华为P10和魅蓝5连接不上，换用华为Nova2可以较为轻松的连上，暂时不知道是什么原因。<br>    2.在网上下载了几个APP：serial WiFi，WiFi TCP/UDP，可以连接到cc3200，但是无法数据通信。想知道是否需要TI官方相关的配套APP才可以。          </p><pre><code>解决一：下载了个APP“magic iperf”,好像是有了点作用，串口打印出已经收到TCP数据，然而没有打印出接收到的数据啊。问题二：修改了程序，输出了接收缓冲区，但是输出的内容让人摸不着头脑。怎么看都不像是正常的数据包。现在最大的问题，应该怎样通过手机给模块发送TCP数据，并且通过串口打印输出到电脑上。代码里面找不到相关的内容，只有socket的创建，绑定端口等操作，在一个叫“BsdTcpServer”的函数里。这个函数，跟一般的建立一个TCP sever的基本思路大同小异，那么讲道理，TCP的接收数据的接口应该就是“sl_Recv”此类的函数，难道这个函数的参数“uBuf.BsdBuf”不是用于存放TCP数据包的吗？现在大致的思路应该是，使用串口中断，将接收到的数据，通过TCP的这个接口函数，发送到移动终端，就好了吧。解决二：问题解决了，其实一直都是通的，但是这个官方的demo并没有将接收到的数据打印出来，仅仅是做了一个接收判断（即接收到数据后就亮一盏灯，然后打印出接收成功的字样）。另外，想要向手机端发送数据需要调用&quot;sl_Send&quot;函数，使用方式与“ sl_Recv ”类似。问题三：现在的现象有点奇怪，两个情况下WiFi模块会无法连接：1.将开关拨到与WiFi模块相连，插上dongle，WiFi无法连接。另外，此时将开关拨到另一边，也不能连接WiFi。只有单独将WiFi模块复位才行。2.在连接上之后，发送AT+NRB，会导致WiFi断开，并再无法连接。解决办法同上，也是要将WiFi模块复位才行。根据以上现象来看，似乎是WiFi跟NB模组连接的串口导致。但是什么样的串口问题会导致这种情况呢？解决三：以上出现的现象原来是因为跟WiFi相连的另一路串口没有配置导致的，与NB模块LOGVIEW口相连的UART0串口，会在NB模块启动的时候收到log数据，导致WiFi模块卡死。为什么会卡死，我还不太明白，为什么没有配置的串口收到数据会导致程序卡死。导致模块复位的原因知道了，是程序里的一个复位Pin脚占用了UART0的串口。问题四：虽然配置好了两路的串口，但是发现，在收发AT命令的时候，两路串口好像会有干扰，导致收到的数据是乱码。之所以会这么觉得，是以为屏蔽了另一路串口问题就解决了。UART0的配置如下： 1.引脚配置</code></pre> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void PinMuxConfig(void)</span><br><span class="line">&#123;</span><br><span class="line">    // Enable Peripheral Clocks</span><br><span class="line">    MAP_PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK);</span><br><span class="line"></span><br><span class="line">    MAP_PinTypeUART(PIN_03, PIN_MODE_7);//UART0</span><br><span class="line"></span><br><span class="line">    MAP_PinTypeUART(PIN_04, PIN_MODE_7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.串口属性配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void LOGVIEWComPort_Init_921600(void)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">   MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8);</span><br><span class="line">   MAP_UARTFIFOEnable(COM_P0);</span><br><span class="line">   MAP_UARTFlowControlSet(COM_P0, UART_FLOWCONTROL_NONE);</span><br><span class="line">  </span><br><span class="line">   MAP_UARTConfigSetExpClk(COM_P0,MAP_PRCMPeripheralClockGet(COM_P0_PERIPH),</span><br><span class="line">                            921600, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |</span><br><span class="line">                                             UART_CONFIG_PAR_NONE));</span><br><span class="line">   MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler);</span><br><span class="line">   MAP_IntPrioritySet(INT_UARTA0,INT_PRIORITY_LVL_0);</span><br><span class="line">   MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待解决四：<br>    进一步尝试，发现是这几句话会导致串口干扰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">    MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8);</span><br><span class="line">    MAP_UARTFIFOEnable(COM_P0);</span><br><span class="line">    MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler);</span><br><span class="line">    MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"> 解决四：</span><br><span class="line">    </span><br><span class="line">    问题原因是没有处理中断接收的数据，导致的干扰，配置好中断的处理函数之后就没有这样的问题了，不是以上这几条语句导致的。</span><br><span class="line"></span><br><span class="line">    问题五：</span><br><span class="line">    socket的数据流程整理了一下，数据结构挺庞大，好在还算清晰。简单的流程如下图：</span><br><span class="line">    ![](https://app.yinxiang.com/shard/s62/res/14408816-1d63-434e-9576-39a18458d2c2) </span><br><span class="line"></span><br><span class="line">然后，数据是怎样从串口传到socket的呢？貌似是通过全局的队列，就是下面的这个函数，在UART的接收中断中执行</span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">void uart_get_char(char c)</span><br><span class="line">&#123;</span><br><span class="line">    char flag = 0;</span><br><span class="line">    portBASE_TYPE xHigherPriorityTaskWoken;</span><br><span class="line">    uart_timer_stop();</span><br><span class="line">    lps_event_timer = 0;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len_queue(&amp;g_p_uart_buf-&gt;queue) == UART_FRAME_MAX_LEN - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">    &#125;</span><br><span class="line">//队列满的情况计数，这部分代码可以复用</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (full_quene(&amp;g_p_uart_buf-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        uart_bug_count++;   //计数用来测试串口数据满的情况</span><br><span class="line">        Report(<span class="string">"full_quene\r\n"</span>);</span><br><span class="line">        LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"full_quene\r\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;lostNew) //丢弃最新的数据</span><br><span class="line">        &#123;</span><br><span class="line">            g_uart_to_sock_cnt++;       </span><br><span class="line">            portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            g_p_uart_buf-&gt;queue.rear = (g_p_uart_buf-&gt;queue.rear + 1) % QUEUE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (g_p_uart_buf-&gt;tmodeState == TMODE_CMD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)  //有些命令以\r\n结束</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里把串口收的数据放到这里</span><br><span class="line">    en_queue(&amp;g_p_uart_buf-&gt;queue, c);</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        g_uart_to_sock_cnt++;</span><br><span class="line">        portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;tmodeState == TMODE_CMD)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_p_uart_buf-&gt;<span class="built_in">echo</span> == ECHO_ON)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">'\r'</span> != c)</span><br><span class="line">                &#123;</span><br><span class="line">                    uart_output_byte(COM_P1, c);</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\b'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                de_queue_font(&amp;g_p_uart_buf-&gt;queue);    // delete <span class="string">'\b'</span></span><br><span class="line">                de_queue_font(&amp;g_p_uart_buf-&gt;queue);    // delete <span class="string">'previous'</span></span><br><span class="line">                uart_output_byte(COM_P1, <span class="string">' '</span>);</span><br><span class="line">                uart_output_byte(COM_P1, <span class="string">'\b'</span>);</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\r'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                g_uart_to_at_cnt++;</span><br><span class="line">                portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            uart_timer_start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上存储数据的操作之后，将队列中的数据存到socket的数组中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">void uart_recv_task(void *argc)</span><br><span class="line">&#123;</span><br><span class="line">    uartParaStruct *pUartPara = (uartParaStruct *)argc;</span><br><span class="line">    threadParaStruct *pThreadPara = pUartPara-&gt;para;</span><br><span class="line">    uartBuf_typeDef *pBuf = l_v_uart_buf;</span><br><span class="line">    char *pBufAt = NULL;</span><br><span class="line">  </span><br><span class="line">    unsigned short pos;</span><br><span class="line">    int i;</span><br><span class="line">    char existSock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pThreadPara-&gt;threadCompleted)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((l_uart_to_sock_cnt &gt; 0))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l_uart_to_sock_cnt &gt; 3)</span><br><span class="line">            &#123;</span><br><span class="line">                l_uart_to_sock_cnt = 3;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pBuf-&gt;queue.font;</span><br><span class="line"></span><br><span class="line">            // 从串口buffer中取出数据</span><br><span class="line">            // 若无网络task，可以使用串口接受callback</span><br><span class="line">            // 故每次直接从队列中取出数据，且tempbuf清楚</span><br><span class="line">            pBuf-&gt;tempBufLen = 0;</span><br><span class="line">            memset(pBuf-&gt;tempBuf, 0, sizeof(pBuf-&gt;tempBuf));</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (empty_quene(&amp;pBuf-&gt;queue))</span><br><span class="line">                &#123;</span><br><span class="line">                    l_uart_to_sock_cnt = 0;</span><br><span class="line">         </span><br><span class="line">                    uart_debug(<span class="string">"The uart queue is empty,need check code\n"</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt;= UART_FRAME_MAX_LEN)</span><br><span class="line">                &#123;</span><br><span class="line">          </span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                de_queue(&amp;pBuf-&gt;queue, &amp;pBuf-&gt;tempBuf[pBuf-&gt;tempBufLen]);</span><br><span class="line">                pBuf-&gt;tempBufLen++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">while</span> (pos != pBuf-&gt;queue.rear);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //uart callback</span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;recv_callback)</span><br><span class="line">                &#123;</span><br><span class="line">                    pBuf-&gt;tempBufLen = pBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_REDAY, (void *)pBuf, pBuf-&gt;tempBuf, pBuf-&gt;tempBufLen);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //still have data,send quene to net task</span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    existSock = 0;</span><br><span class="line">                    <span class="keyword">if</span> (g_sock_used[1] == TRUE) //当前sock建立</span><br><span class="line">                    &#123;</span><br><span class="line">    </span><br><span class="line">                      pBuf-&gt;sockSendLen[1] = pBuf-&gt;tempBufLen;</span><br><span class="line">                      existSock = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (existSock)</span><br><span class="line">                    &#123;</span><br><span class="line">                        msleep(_DELAY_SWITCH_CONTEXT_MS); // 任务挂起，让给高优先级的sock</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        existSock = 0;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> ((g_sock_used[1] == TRUE) &amp;&amp; (g_sock_tcp[1] == TRUE))</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="keyword">if</span> (pBuf-&gt;sockSendLen[1] &gt; 0) //  1</span><br><span class="line">                          &#123;</span><br><span class="line">                            existSock = 1;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (existSock)</span><br><span class="line">                        &#123;</span><br><span class="line">                            msleep(_DELAY_FOR_WAIT_SOCK);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l_uart_to_sock_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l_uart_to_sock_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            msleep(30);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，在socket的任务中会检测是否有数据存在，有的话就通过接口函数发送到网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//如果接收到了数据</span><br><span class="line">      <span class="keyword">if</span> (g_p_uart_buf != NULL)</span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT)</span><br><span class="line">        &#123;</span><br><span class="line">          int send_len = g_p_uart_buf-&gt;sockSendLen[id];</span><br><span class="line">          //socka_debug(<span class="string">"uart recv data\r\n"</span>);</span><br><span class="line">          //socka_debug(<span class="string">"id=%d\r\n"</span>, id);</span><br><span class="line">          start_time = xTaskGetTickCount();   // 获取ejoin 开始时间</span><br><span class="line">          //<span class="keyword">if</span>(strlen(g_p_uart_buf-&gt;tempBuf))</span><br><span class="line">          </span><br><span class="line">          ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0);</span><br><span class="line">          first_time = xTaskGetTickCount();</span><br><span class="line">          LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"(%d,%u)\r\n"</span>, first_time-start_time, start_time);</span><br><span class="line">          <span class="keyword">if</span> ((ret &lt; 0)  || (ret == 0))</span><br><span class="line">          &#123;</span><br><span class="line">            socka_debug(<span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            sock_fd = -1;</span><br><span class="line">            </span><br><span class="line">            pThreadPara-&gt;threadCompleted = TRUE;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (send_len != ret)      //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了</span><br><span class="line">          &#123;</span><br><span class="line">            //网络未正常断开的时候，不能用send检测到</span><br><span class="line">            //这里发送失败就选择重新发送，接收的select中会检测到断网</span><br><span class="line">            //socka_debug(<span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (reSendTimers++ &gt; NET_RECONNECT_TIMES)   // 丢弃数据</span><br><span class="line">            &#123;</span><br><span class="line">              //reSendTimers = reSendTimers;</span><br><span class="line">              g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              msleep(20);</span><br><span class="line">              <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          needSleep = 0;</span><br><span class="line">          reSendTimers = 0;</span><br><span class="line">          g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(NULL != pNetBuf-&gt;recv_callback)  // 150423</span><br><span class="line">          &#123;</span><br><span class="line">            pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          //          socka_debug(<span class="string">"uart not recvd, wait...\r\n"</span>);</span><br><span class="line">          osi_Sleep(10);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>//如果接收到了数据<br>      if (g_p_uart_buf != NULL)<br>      {<br>        if (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT)<br>        {<br>          int send_len = g_p_uart_buf-&gt;sockSendLen[id];<br>          //socka_debug(“uart recv data\r\n”);<br>          //socka_debug(“id=%d\r\n”, id);<br>          start_time = xTaskGetTickCount();   // 获取ejoin 开始时间<br>          //if(strlen(g_p_uart_buf-&gt;tempBuf))</p><pre><code>      ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0);      first_time = xTaskGetTickCount();      LSD_Debug(LSD_DEBUG_LEVEL_3, &quot;(%d,%u)\r\n&quot;, first_time-start_time, start_time);      if ((ret &lt; 0)  || (ret == 0))      {        socka_debug(&quot;socka send error\r\n&quot;);        LSD_Debug(LSD_DEBUG_LEVEL_3, &quot;socka send error\r\n&quot;);        close(sock_fd);        sock_fd = -1;        pThreadPara-&gt;threadCompleted = TRUE;        break;      }      else if (send_len != ret)      //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了      {        //网络未正常断开的时候，不能用send检测到        //这里发送失败就选择重新发送，接收的select中会检测到断网        //socka_debug(&quot;sock(%d) send fail\r\n&quot;, id);        LSD_Debug(LSD_DEBUG_LEVEL_3, &quot;sock(%d) send fail\r\n&quot;, id);        if (reSendTimers++ &gt; NET_RECONNECT_TIMES)   // 丢弃数据        {          //reSendTimers = reSendTimers;          g_p_uart_buf-&gt;sockSendLen[id] = 0;        }        else        {          msleep(20);          continue;        }      }      needSleep = 0;      reSendTimers = 0;      g_p_uart_buf-&gt;sockSendLen[id] = 0;      if(NULL != pNetBuf-&gt;recv_callback)  // 150423      {        pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0);      }    }    else    {      //          socka_debug(&quot;uart not recvd, wait...\r\n&quot;);      osi_Sleep(10);    }  }现在遇到的麻烦是，开启sockB的时候，会导致堆栈溢出。很好，堆栈溢出的问题解决了，原因是任务分配的内存大小不够，sockB的任务。然而，新的问题又出现了，使用sockB无法连接。最新问题，当数据大于等于512个字节时，队列的缓冲区就满了，很奇怪，明明分配了0x1600的空间，却用不到那么空间。解决五：上述问题都解决了，但实际上还遗留着一个问题，就是使用socketB作为lowview的数据通道时，串口中断的队列会溢出。现在的做法是，将socketB换成了AT命令的数据通道。问题得以规避。原因却没有找到，大概是socketB发送数据时出队的设计这边有些问题，支撑不了这么快的数据。问题六：AT串口出现断包的现象，想想是什么原因吧，可是NB模块又是返回正确的数据长度以及OK，然而服务器那边却收不到断了的数据包。这是为什么？明天早上先把串口换一下试试。解决六：接收断包的现象可能跟WiFi模块的信号有关，使用手机做热点的时候并不会有这种现象，并且，这现象只发生在模块刚启动的一会儿，过一会就不再有这种情况。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#遇到的问题与解决&lt;/p&gt;
&lt;p&gt;没接触过这类板子，有点陌生，不要紧，一步一步来。&lt;br&gt;    问题一：&lt;br&gt;    1.烧写了官方的SDK，按照提示，通过WiFi直连连接到了手机，但是失败概率很高，使用华为P10和魅蓝5连接不上，换用华为Nova2可以较为轻松的连上，
      
    
    </summary>
    
      <category term="CC32xx系列开发" scheme="https://deflin.github.io/categories/CC32xx%E7%B3%BB%E5%88%97%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CC3200" scheme="https://deflin.github.io/tags/CC3200/"/>
    
      <category term="单片机" scheme="https://deflin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="WiFi" scheme="https://deflin.github.io/tags/WiFi/"/>
    
  </entry>
  
  <entry>
    <title>va_start和va_end使用详解</title>
    <link href="https://deflin.github.io/2018/06/01/va_start%E5%92%8Cva_end%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://deflin.github.io/2018/06/01/va_start和va_end使用详解/</id>
    <published>2018-06-01T03:21:52.155Z</published>
    <updated>2018-06-05T11:53:49.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表</p><p>void foo(…);<br>void foo(parm_list,…);<br>这种方式和我们以前认识的不大一样，但我们要记住这是C中一种传参的形式，在后面我们就会用到它。</p><p>2.函数参数的传递原理<br>　　函数参数是以数据结构:栈的形式存取,从右至左入栈。</p><p>　　首先是参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址，举个例子如下：<br>void func(int x, float y, char z);<br>　　那么，调用函数的时候，实参 char z 先进栈，然后是 float y，最后是 int x，因此在内存中变量的存放次序是 x-&gt;y-&gt;z，因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过指针移位运算，则总可以顺藤摸瓜找到其他的输入变量。</p><p>　　下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：<br>typedef char<em> va_list;<br>void va_start ( va_list ap, prev_param ); /</em> ANSI version */<br>type va_arg ( va_list ap, type );<br>void va_end ( va_list ap );<br>va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。</p><p><step 1=""> 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</step></p><p><step 2=""> 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数；</step></p><p><step 3=""> 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；</step></p><p><step 4=""> 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。</step></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream.h&gt; void fun(int a, ...) &#123; 　　int *temp = &amp;a;　　temp++;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">for</span> (int i = 0; i &lt; a; ++i) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　cout &lt;&lt; *temp &lt;&lt; endl; </span><br><span class="line">　　　　temp++; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">　　int a = 1; </span><br><span class="line">　　int b = 2; </span><br><span class="line">　　int c = 3; </span><br><span class="line">　　int d = 4; </span><br><span class="line">　　fun(4, a, b, c, d); </span><br><span class="line">　　system(<span class="string">"pause"</span>); </span><br><span class="line">　　<span class="built_in">return</span> 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Output:: </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>3:获取省略号指定的参数<br>　　在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。像这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void TestFun(char* pszDest, int DestLen, const char* pszFormat, ...) &#123; va_list args; va_start(args, pszFormat); //一定要“...”之前的那个参数_vsnprintf(pszDest, DestLen, pszFormat, args); va_end(args); &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4.演示如何使用参数个数可变的函数，采用ANSI标准形式 </span><br><span class="line"><span class="comment">#include 〈stdio.h〉 </span></span><br><span class="line"><span class="comment">#include 〈string.h〉 </span></span><br><span class="line"><span class="comment">#include 〈stdarg.h〉 </span></span><br><span class="line"></span><br><span class="line">/*函数原型声明，至少需要一个确定的参数，注意括号内的省略号*/ </span><br><span class="line">int demo( char, ... ); </span><br><span class="line">void main( void ) </span><br><span class="line">&#123; </span><br><span class="line">   demo(<span class="string">"DEMO"</span>, <span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"demo!"</span>, <span class="string">""</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*ANSI标准形式的声明方式，括号内的省略号表示可选参数*/ </span><br><span class="line">int demo( char msg, ... ) </span><br><span class="line">&#123; </span><br><span class="line">       /*定义保存函数参数的结构*/</span><br><span class="line">   va_list argp; </span><br><span class="line">   int argno = 0; </span><br><span class="line">   char para; </span><br><span class="line">　　   /*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/ </span><br><span class="line">   va_start( argp, msg ); </span><br><span class="line">   <span class="keyword">while</span> (1) </span><br><span class="line">       &#123; </span><br><span class="line">        para = va_arg( argp, char); </span><br><span class="line">           <span class="keyword">if</span> ( strcmp( para, <span class="string">""</span>) == 0 ) </span><br><span class="line">               <span class="built_in">break</span>; </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"Parameter #%d is: %s\n"</span>, argno, para); </span><br><span class="line">           argno++; </span><br><span class="line">&#125; </span><br><span class="line">va_end( argp ); </span><br><span class="line">/*将argp置为NULL*/</span><br><span class="line"><span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表&lt;/p&gt;
&lt;p&gt;void foo(…);&lt;br&gt;void 
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>可变参数函数用法</title>
    <link href="https://deflin.github.io/2018/05/30/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <id>https://deflin.github.io/2018/05/30/可变参数函数用法/</id>
    <published>2018-05-30T13:26:12.694Z</published>
    <updated>2018-06-05T11:54:13.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>typedef char* va_list;//用于声明一个指向参数列表的字符型指针变量<br>void va_start(va_list ap,prev_param);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的第一个参数，通常用于指定可变参数列表中参数的个数<br>void va_arg(va_list ap,type);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的数据类型<br>void va_end(va_list ap);//将存放可变参数字符串的变量清空（赋值为NULL）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int sum(int count,...)//计算和</span><br><span class="line">&#123;</span><br><span class="line">     int sum = 0;</span><br><span class="line">     int i;</span><br><span class="line">     va_list ap;</span><br><span class="line">     va_start(ap,count);</span><br><span class="line">     <span class="keyword">for</span>(i=0;i&lt;count;++i)</span><br><span class="line">     &#123;</span><br><span class="line">          sum+=va_arg(ap,int);</span><br><span class="line">     &#125;</span><br><span class="line">     va_end(ap);</span><br><span class="line">     <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>,sum(3,1,2,3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;example&quot;&gt;&lt;a href=&quot;#example&quot; class=&quot;headerlink&quot; title=&quot;example&quot;&gt;&lt;/a&gt;example&lt;/h2&gt;&lt;p&gt;typedef char* va_list;//用于声明一个指向参数列表的字符型指针变量&lt;br&gt;vo
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>关于回调函数的理解</title>
    <link href="https://deflin.github.io/2018/05/26/%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://deflin.github.io/2018/05/26/关于回调函数的理解/</id>
    <published>2018-05-26T14:07:01.285Z</published>
    <updated>2018-06-05T11:54:02.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p><p>实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。</p><p>populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdlib.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line">// 回调函数 </span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span> (size_t i=0; i&lt;arraySize; i++) </span><br><span class="line">        array[i] = getNextValue(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 获取随机值 </span><br><span class="line">int getNextRandomValue(void) &#123; </span><br><span class="line"></span><br><span class="line">     <span class="built_in">return</span> rand(); </span><br><span class="line">&#125; </span><br><span class="line">int main(void) </span><br><span class="line">&#123; </span><br><span class="line">    int myarray[10];</span><br><span class="line"></span><br><span class="line">//此处getNextValue指向 getNextRandomValue函数的地址，起到调用作用</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, myarray[i]); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">    <span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;example&quot;&gt;&lt;a href=&quot;#example&quot; class=&quot;headerlink&quot; title=&quot;example&quot;&gt;&lt;/a&gt;example&lt;/h2&gt;&lt;p&gt;实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
