<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林定益想去NASA捡垃圾</title>
  
  <subtitle>Stay hungry,Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://deflin.github.io/"/>
  <updated>2018-09-01T01:58:33.529Z</updated>
  <id>https://deflin.github.io/</id>
  
  <author>
    <name>Def Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SCons的使用</title>
    <link href="https://deflin.github.io/2018/09/01/SCons%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://deflin.github.io/2018/09/01/SCons的使用/</id>
    <published>2018-09-01T01:21:09.948Z</published>
    <updated>2018-09-01T01:58:33.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>SCons是一个Python写的自动化构建工具，和GNU make相比优点明显：<br>1.移植性：Python能运行的地方，就能运行SCons<br>2.扩展性：理论上SCons只是提供了Python的类，SCons使用者可以在这个类的基础上做所有Python能做的事情。比如想把一个已经使用了Makefile大型工程切换到SCons，就可以保留原来的Makefile，并使用Python解析Makefile中的编译选项、源/目标文件等，作为参数传递给SCons,完成编译。<br>3、智能：SCons继承了autoconf/automake的功能，自动解析系统的include路径、typedef等；“以全局的观点来看所有的依赖关系”  </p><h1 id="二、SCons文件"><a href="#二、SCons文件" class="headerlink" title="二、SCons文件"></a>二、SCons文件</h1><p>SCons中可能出现的文件：  </p><p><font color="#0099ff" size="3">SConstruct,Sconstruct,sconstruct,SConscript</font><br>SCons将在当前目录以下次序:SConstruct,Sconstruct,sconstruct来搜索配置文件，从读取的第一个文件中读取相关配置。<br>在配置文件SConstruct中可以使用函数SConscript()函数来定附属的配置文件。按惯例，这些附属配置文件被命名为“SConscript”,当然也可以使用任意其它名字。  </p><h1 id="三、SCons的命令行参数"><a href="#三、SCons的命令行参数" class="headerlink" title="三、SCons的命令行参数"></a>三、SCons的命令行参数</h1><p>scons:执行SConstruct中脚本<br>scons -c:clean<br>scons -Q:只显示编译信息，去除多余的打印信息<br>scons -Q<br>–implicit-cache hello:保存依赖关系<br>–implicit-deps-changed:强制更新依赖关系<br>–implicit-deps-unchanged:强制使用原先的依赖关系，即使已经改变  </p><h1 id="四、SConstruct提供的方法"><a href="#四、SConstruct提供的方法" class="headerlink" title="四、SConstruct提供的方法"></a>四、SConstruct提供的方法</h1><p>1、Program:生成可执行文件<br>    Program(‘hello.c’)  编译hello.c可执行文件，根据系统自动生成(hello.exe on Windows; hello on POSIX)<br>    Program(‘hello’,’hello.c’) 指定Output文件名(hello.exe on Windows; hello on POSIX)<br>    Program([‘hello.c’, ‘file1.c’, ‘file2.c’]) 编译多个文件，Output文件名以第一个文件命名<br>    Program(source = “hello.c”,target = “hello”)<br>    Program(target = “hello” , source = “hello.c”)<br>    Program(‘hello’, Split(‘hello.c file1.c file2.c’)) 编译多个文件</p><pre><code>Program(Glob(&quot;*.c&quot;))src = [&quot;hello.c&quot;,&quot;foo.c&quot;];Program(src)  </code></pre><p>2、Object：生成目标文件</p><pre><code>Object(&apos;hello.c&apos;) 编译hello.c目标文件，根据系统自动生成(hello.obj on Windows; hello.o on POSIX)</code></pre><p>3、Library：生成静态/动态库文件</p><pre><code>Library(&apos;foo&apos;, [&apos;f1.c&apos;, &apos;f2.c&apos;, &apos;f3.c&apos;]) 编译librarySharedLibrary(&apos;foo&apos;, [&apos;f1.c&apos;, &apos;f2.c&apos;, &apos;f3.c&apos;]) 编译 shared libraryStaticLibrary(&apos;bar&apos;, [&apos;f4.c&apos;, &apos;f5.c&apos;, &apos;f6.c&apos;]) 编译 static library库的使用：Program(&apos;prog.c&apos;, LIBS=[&apos;foo&apos;, &apos;bar&apos;], LIBPATH=&apos;.&apos;) 连接库，不需加后缀或是前缀</code></pre><p>4、SourceSignatures：判断源文件是否修改<br>    SourceSignatures(‘MD5’)     根据内容是否改变，默认方式<br>    SourceSignatures(‘timestamp’) 根据修改时间</p><p>5、TargetSignatures：判断目标文件是否改变<br>    TargetSignatures(‘build’)   根据编译结果<br>    TargetSignatures(‘content’)  根据文件内容，如果只是加了句注释，将不会被重新编译</p><p>6、Ignore：忽略依赖关系</p><pre><code>Ignore(hello, &apos;hello.h&apos;)  忽略某个依赖关系</code></pre><p>7、Depends：明确依赖关系</p><pre><code>Depends(hello, &apos;other_file&apos;) 明确依赖关系 </code></pre><p>8、SConscript：scons的配置文件。</p><pre><code>源文件的目录结构如下：src：|    SConstruct|    test.cpp|    mA(目录)：     |     SConscript     |     func.cpp其中test.cpp为主文件，中调用func.cpp中定义的函数SConstruct内容如下：  </code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = Object(Glob(<span class="string">"*.cpp"</span>))</span><br><span class="line">Return(<span class="string">"obj"</span>)</span><br></pre></td></tr></table></figure><p>上例中，在主目录中执行 scons就可以编译整个”工程”。SConstruct编译主目录中的test.cpp，并通过SConscript编译mA目录下的源文件，并最终生成可执行文件；SConscript用于编译mA中的func.cpp并把生成的func.o传递给主目录的SConstruct。</p><p>10.env：环境变量<br>     环境变量用于设置在编译过程中的各种参数，可以用下面的SConstruct打印环境变量的所有信息(实际上env就是一个python字典)<br>     可以使用如下的SConstruct查看环境变量的内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env = Environment()</span><br><span class="line">dict = env.Dictionary()</span><br><span class="line">keys = dict.keys()</span><br><span class="line">keys.sort()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"construction variable = '%s', value = '%s'"</span> % (key, dict[key])</span><br></pre></td></tr></table></figure></p><p>环境变量的使用：<br>         env = Environment()   #创建默认的环境变量，默认scons会按编译器的默认选项来进行编译<br>         import os<br>         env = Environment(CC = ‘gcc’,CCFLAGS = ‘-O2’) #创建并设置环境 变量<br>         env.Program(‘foo.c’)</p><pre><code>环境变量的复制：    env = Environment(CC = &apos;gcc&apos;)    opt = env.Clone(CCFLAGS = &apos;-O2&apos;)    dbg = env.Clone(CCFLAGS = &apos;-g&apos;)环境变量的替换：    env = Environment(CCFLAGS = &apos;-DDEFINE1&apos;)    env.Replace(CCFLAGS = &apos;-DDEFINE2&apos;)    env.Program(&apos;foo.c&apos;) 环境变量的输入输出：用于统一多目录源文件的编译选项，如：src：|    SConstruct|    libstlport.a|    test.cpp|     include(目录)：     |    foo.h|    mA(目录)：     |    SConscript     |    func.cpptest.cpp和mA/func.cpp都引用了include/foo.h,test.cpp调用了mA/func.cpp的功能函数,其中include/foo.h中定义了一个包含string类型的类。SConstruct如下：</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">env = Environment()</span><br><span class="line">flags = env.ParseFlags([<span class="string">'-pthread -I/usr/include/stlport '</span>,<span class="string">' -L .'</span>])</span><br><span class="line">env.MergeFlags(class_flags)</span><br><span class="line">subobj = SConscript([<span class="string">'mA/SConscript'</span>])</span><br><span class="line">obj = subobj + env.Object(Glob(<span class="string">"*.cpp"</span>))</span><br><span class="line">env.Program(<span class="string">"test"</span>,list(obj),LIBS = [<span class="string">'libstlport.a'</span>])</span><br><span class="line">``` </span><br><span class="line">mA/SConscrip如下:  </span><br><span class="line">```python</span><br><span class="line">obj = Object(Glob(<span class="string">"*.cpp"</span>))</span><br><span class="line">Return(<span class="string">"obj"</span>)</span><br></pre></td></tr></table></figure><p>不出意外的话上边的工程编译可以通过，但是运行的时候会Aborted。因为test.cpp,mA/func.cpp都使用了包含string类型的那个类，但是由于编译环境的不同，test.cpp认为string变量的大小是24字节, mA/func.cpp认为string变量的大小是4个字节(libstlport.a捣的鬼)。</p><pre><code> 解决问题的办法就是环境变量输出，修改SConstruct和mA/SConscript如下：SConstruct：  </code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">env = Environment()</span><br><span class="line">flags = env.ParseFlags([<span class="string">'-pthread -I/usr/include/stlport '</span>,<span class="string">' -L .'</span>])</span><br><span class="line">env.MergeFlags(class_flags)</span><br><span class="line">Export(<span class="string">'env'</span>)</span><br><span class="line">subobj = SConscript([<span class="string">'mA/SConscript'</span>],exports = <span class="string">'env'</span>)</span><br><span class="line">obj = subobj + env.Object(Glob(<span class="string">"*.cpp"</span>))</span><br><span class="line">env.Program(<span class="string">"test"</span>,list(obj),LIBS = [<span class="string">'libstlport.a'</span>])</span><br></pre></td></tr></table></figure><p>mA/SConscript:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import(<span class="string">'env'</span>)</span><br><span class="line">obj = env.Object(Glob(<span class="string">"*.cpp"</span>))</span><br><span class="line">Return(<span class="string">"obj"</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;SCons是一个Python写的自动化构建工具，和GNU make相比优点明显：&lt;br&gt;1.移植性：Python能运行的地方
      
    
    </summary>
    
      <category term="Hi2115开发" scheme="https://deflin.github.io/categories/Hi2115%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="https://deflin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《调试九法》读书笔记</title>
    <link href="https://deflin.github.io/2018/08/24/%E3%80%8A%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://deflin.github.io/2018/08/24/《调试九法》读书笔记/</id>
    <published>2018-08-24T14:19:16.182Z</published>
    <updated>2018-08-24T14:19:20.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="制造失败"><a href="#制造失败" class="headerlink" title="制造失败"></a>制造失败</h1><h2 id="如果做了所有尝试之后问题仍然间歇性发生"><a href="#如果做了所有尝试之后问题仍然间歇性发生" class="headerlink" title="如果做了所有尝试之后问题仍然间歇性发生"></a>如果做了所有尝试之后问题仍然间歇性发生</h2><p>制造失败的目的有三个：<br><br>1.观察错误<br><br>2.查找线索<br><br>3.确认是否已修复<br><br>记住，问题是美哦与自己的思维的，失败肯定有原因，你一定能够找到它。</p><h4 id="仔细观察失败"><a href="#仔细观察失败" class="headerlink" title="仔细观察失败"></a>仔细观察失败</h4><p>如果他不是每次都发生，那么就必须忽略掉不发生的时候，而在它每次发生时观察它。关键是在每次运行的时候捕捉相关信息，以便在发生失败之后查看这些数据。方法就是让系统在运行的时候尽可能多地输出信息，并把它们记录到“调试日志”文件中。</p><h4 id="不要盲目相信统计数据"><a href="#不要盲目相信统计数据" class="headerlink" title="不要盲目相信统计数据"></a>不要盲目相信统计数据</h4><p>制造失败的第二个目的是获得问题发生的线索。当发生一个间歇性问题时，你可以注意那些看起来与问题有关的操作模式。这种思路是没有问题的，但不要被表面现象所误导。<br>如果失败是随机发生的，你可能无法收集到足够多地统计样本来作出判断，例如，用左手点击按钮与用右手点击按钮是否有着很大的区别。在很多时候，巧合会使你误认为莫衷条件比其他条件更可能引发问题。然后你就会开始仔细研究“这两种条件之间有什么区别”，由于你找错了对象，这将会浪费大量时间。<br>这并不意味着你所看到的这些巧合的区别与问题不存在任何联系。但是，如果它们没有直接的影响，那么它们与问题的联系将会隐藏在其他随机因素背后，这时通过查看这些区别来找到原因的机会是非常渺茫的。<br>当你捕获到足够多的信息时，就可以确定哪些因素总是与bug有关，或者哪些因素从来都与bug无关。在查找问题根源的时候，这些因素是需要重点关注的。</p><h4 id="是已修复bug，还是仅仅由于运气好，它不再发生了"><a href="#是已修复bug，还是仅仅由于运气好，它不再发生了" class="headerlink" title="是已修复bug，还是仅仅由于运气好，它不再发生了"></a>是已修复bug，还是仅仅由于运气好，它不再发生了</h4><p>如果失败是随机发生的，那么要想证明bug是否已被修复就会困难得多，这一点是毫无疑问的。如果在测试的时候，每10次发生1次失败，在你“修复”它之后，变成了每30次发生1次，而你在测试28次之后终止了测试，这时你认为问题已修复，但实际上并没有。<br>最好的办法是找到一个总是与失败有关的事件序列。即使这个序列本身就是间歇性的，但当它发生时，100%会发生失败。然后，当你认为已修复bug时，就可以运行测试，直到这个序列出现，如果没有发生失败，那么你确实已修复了bug。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;制造失败&quot;&gt;&lt;a href=&quot;#制造失败&quot; class=&quot;headerlink&quot; title=&quot;制造失败&quot;&gt;&lt;/a&gt;制造失败&lt;/h1&gt;&lt;h2 id=&quot;如果做了所有尝试之后问题仍然间歇性发生&quot;&gt;&lt;a href=&quot;#如果做了所有尝试之后问题仍然间歇性发生&quot; class
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://deflin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="调试" scheme="https://deflin.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CoAP协议——格式详解</title>
    <link href="https://deflin.github.io/2018/06/10/CoAP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://deflin.github.io/2018/06/10/CoAP协议格式详解/</id>
    <published>2018-06-10T06:47:00.374Z</published>
    <updated>2018-06-10T07:12:21.382Z</updated>
    
    <content type="html"><![CDATA[<p>CoAP是受限制的应用协议(Constrained Application Protocol)的代名词。在当前由PC机组成的世界，交换是通过TCP和应用层协议HTTP实现的。但是对于小型设备而言，实现TCP和HTTP协议显然是一个过分的要求。为了让小设备可以接入，CoAP协议被设计出来。CoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。CoAP协议非常小巧，最小的包仅为4字节。</p><h2 id="1-CoAP协议综述"><a href="#1-CoAP协议综述" class="headerlink" title="1.CoAP协议综述"></a>1.CoAP协议综述</h2><p>和其他TCP IP协议簇中的协议一样，CoAP协议总是以“头”的形式出现在负载之前，而负载和CoAP头之间使用单字节0xFF分离。学习CoAP协议最好的方法便是结合RFC文档，详细分析CoAP协议报文格式的每一部分，便是CoAP协议报文结构示意图。</p><p><img src="https://app.yinxiang.com/shard/s62/res/2fdaef85-ef39-4091-9791-a7d66f6228b2/wKioL1U1xTSxeGZEAABcjxUkJbc353.png" alt=""></p><h2 id="2-CoAP协议报文结构示意图"><a href="#2-CoAP协议报文结构示意图" class="headerlink" title="2.CoAP协议报文结构示意图"></a>2.CoAP协议报文结构示意图</h2><p>【Ver】 版本编号，指示CoAP协议的版本号。类似于HTTP 1.0 HTTP 1.1。版本编号占2位，取值为01B。</p><p>　　【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。</p><p>　　【TKL】CoAP标识符长度。CoAP协议中具有两种功能相似的标识符，一种为Message ID(报文编号)，一种为Token(标识符)。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。</p><p>　　【Code】功能码/响应码。Code在CoAP请求报文和响应报文中具有不同的表现形式，Code占一个字节，它被分成了两部分，前3位一部分，后5位一部分，为了方便描述它被写成了c.dd结构。其中0.XX表示CoAP请求的某种方法，而2.XX、4.XX或5.XX则表示CoAP响应的某种具体表现。</p><p>　　【Message ID】报文编号</p><p>　　【Token】标识符具体内容，通过TKL指定Token长度。</p><p>　　【Option】报文选项，通过报文选项可设定CoAP主机，CoAP URI，CoAP请求参数和负载媒体类型等等。</p><p>　　【1111 1111B】CoAP报文和具体负载之间的分隔符。</p><h2 id="3-Code部分详解"><a href="#3-Code部分详解" class="headerlink" title="3.Code部分详解"></a>3.Code部分详解</h2><p>　Code部分被分成了两部分，为了便于阅读，Code被描述为c.dd形式。具体内容可参考RFC7252 #12.1.1 Method Codes</p><h3 id="3-1-请求"><a href="#3-1-请求" class="headerlink" title="3.1 请求"></a>3.1 请求</h3><p>在CoAP请求中，Code被定义为CoAP请求方法，这些方法有GET、POST、PUT和DELETE，这些方法和HTTP协议非常相似。</p><p>　　【0.01】GET方法——用于获得某资源</p><p>　　【0.02】POST方法——用于创建某资源</p><p>　　【0.03】PUT方法——用于更新某资源</p><p>　　【0.04】DELETE方法——用于删除某资源</p><h3 id="3-2-响应"><a href="#3-2-响应" class="headerlink" title="3.2 响应"></a>3.2 响应</h3><p>在CoAP响应中，Code被定义为CoAP响应码，类似于HTTP 200 OK等等。</p><p>　　【2.01】Created</p><p>　　【2.02】Deleted</p><p>　　【2.03】Valid</p><p>　　【2.04】Changed</p><p>　　【2.05】Content。类似于HTTP 200 OK</p><p>　　【4.00】Bad Request 请求错误，服务器无法处理。类似于HTTP 400。</p><p>　　【4.01】Unauthorized 没有范围权限。类似于HTTP 401。</p><p>　　【4.02】Bad Option 请求中包含错误选项。</p><p>　　【4.03】Forbidden 服务器拒绝请求。类似于HTTP 403。</p><p>　　【4.04】Not Found 服务器找不到资源。类似于HTTP 404。</p><p>　　【4.05】Method Not Allowed 非法请求方法。类似于HTTP 405。</p><p>　　【4.06】Not Acceptable 请求选项和服务器生成内容选项不一致。类似于HTTP 406。</p><p>　　【4.12】Precondition Failed 请求参数不足。类似于HTTP 412。</p><p>　　【4.15】Unsuppor Conten-Type 请求中的媒体类型不被支持。类似于HTTP 415。</p><p>　　【5.00】Internal Server Error 服务器内部错误。类似于HTTP 500。</p><p>　　【5.01】Not Implemented 服务器无法支持请求内容。类似于HTTP 501。</p><p>　　【5.02】Bad Gateway 服务器作为网关时，收到了一个错误的响应。类似于HTTP 502。</p><p>　　【5.03】Service Unavailable 服务器过载或者维护停机。类似于HTTP 503。</p><p>　　【5.04】Gateway Timeout 服务器作为网关时，执行请求时发生超时错误。类似于HTTP 504。</p><p>　　【5.05】Proxying Not Supported 服务器不支持代理功能。</p><h2 id="4-Option部分详解"><a href="#4-Option部分详解" class="headerlink" title="4.Option部分详解"></a>4.Option部分详解</h2><p>CoAP支持多个Option，CoAP的Option的表示方法比较特殊，采用增量的方式描述，细节可参考RFC7252 #3.1</p><p><img src="https://app.yinxiang.com/shard/s62/res/184076a0-b5d6-430b-a5de-9da3d07f4500/wKiom1U1xDTxJI7KAAB4I_iMBYc005.png" alt=""></p><p>CoAP支持多个Option，CoAP的Option的表示方法比较特殊，采用增量的方式描述，细节可参考RFC7252 #3.1</p><p>　　一般情况下Option部分包含Option Delta、Option Length和Option Value三部分。</p><p>　　【Option Delta】表示Option的增量，当前的Option的具体编号等于之前所有Option Delta的总和。</p><p>　　【Option Length】表示Option Value的具体长度。</p><p>　　【Option Value】表示Option具体内容</p><p>　　CoAP中所有的Option都采用编号的方式，这些Option及编号的定义如下图所示。</p><p><img src="https://app.yinxiang.com/shard/s62/res/a554407c-cd0f-4e15-a822-f9539737c4f3/wKiom1U1xE7QThc7AAEv6fRXN1E676.png" alt=""></p><p>在这些option中，Uri-Host、Uri-Port、Uri-Path和Uri-Query等和资源“位置”和参数有关。</p><p>　　【3】Uri-Host:CoAP主机名称，例如iot.eclipse.org</p><p>　　【7】Uri-Port:CoAP端口号，默认为5683</p><p>　　【11】Uri-Path:资源路由或路径，例如\temperature。资源路径采用UTF8字符串形式，长度不计第一个”\”。</p><p>　　【15】Uri-Query:访问资源参数，例如?value1=1&amp;value2=2，参数与参数之间使用“&amp;”分隔，Uri-Query和Uri-Path之间采用“?”分隔。</p><p>　　在这些option中，Content-Format和Accept用于表示CoAP负载的媒体格式</p><p>　　【12】Content-Format:指定CoAP复杂媒体类型，媒体类型采用整数描述，例如application/json对应整数50，application/octet-stream对应整数40。</p><p>　　【17】Accept: 指定CoAP响应复杂中的媒体类型，媒体类型的定义和Content-Format相同。</p><p>　　CoAP协议中支持多个Option，例如</p><p>　　第一个Option Delta=11，表示该Option表示Uri-Path(11)</p><p>　　第二个Option Delta=1，表示该Option=1+11，表示Content-Format(12)</p><p>　　第三个Option Delta=3，表示该Option=3+1+11，表示Uri-Query(15)</p><p>　　CoAP采用这样的方式表示多个Option，而每种Option都可以在HTTP协议中找到对应项。</p><h2 id="5-Content-Format描述"><a href="#5-Content-Format描述" class="headerlink" title="5.Content-Format描述"></a>5.Content-Format描述</h2><p>CoAP支持多种媒体类型，具体可参考RFC7252 #12.3。从下图的信息可以发现，CoAP协议中关于媒体类型的定义比较简单，未来应该会根据实际情况扩展。</p><p><img src="https://app.yinxiang.com/shard/s62/res/f0354613-2103-491d-a245-8d8f638ab9d4/wKioL1U1xeSR_2t9AACo9vCkTOU789.png" alt=""></p><p>【text/plain】 编号为0，表示负载为字符串形式，默认为UTF8编码。</p><p>　　【application/link-format】编号为40，CoAP资源发现协议中追加定义，该媒体类型为CoAP协议特有。</p><p>　　【application/xml】编号为41，表示负载类型为XML格式。</p><p>　　【application/octet-stream】编号为42，表示负载类型为二进制格式。</p><p>　　【application/exi】编号为47，表示负载类型为“精简XML”格式。(翻译不一定准确)</p><p>　　另外，还有一种格式也北IANA认定，也会在CoAP协议中广泛使用那便是CBOR格式，该格式可理解为二进制JSON格式。</p><p>　　【applicaiton/cbor】编号为60。</p><h2 id="6-示例"><a href="#6-示例" class="headerlink" title="6.示例"></a>6.示例</h2><p>该示例来自于RFC7252。</p><p>　　【流程描述】</p><p>　　CoAP客户端通过GET方法从Server端获得温度传感器数据，CoAP URI如下</p><p>　　coap://<a href="http://www.server.com/temperautre" target="_blank" rel="noopener">www.server.com/temperautre</a></p><p>　　CoAP请求采用CON报文，Server接收到CON报文必须返回一个ACK报文。CoAP请求采用0.01 GET方法，若操作成功CoAP Server返回2.05 Content，相当于HTTP 200 OK。请求和响应的MID必须完全相同，此处为0x7d34。请求响应中的Token域为空。CoAP请求中包含Option，该Option的类型为Uri-Path，那么Option Delta的值为0+11=11，Option Value的值为字符串形式的“temperature”。CoAP返回中包含温度数据，使用字符串形式描述，具体值为”22.3”。</p><p><img src="https://app.yinxiang.com/shard/s62/res/33faa5ba-e105-4632-86b9-d095d4f96255/wKiom1U1xKiQFK_0AABoOl6mUps467.png" alt=""></p><p><img src="https://app.yinxiang.com/shard/s62/res/d3e678fd-5d67-4578-9ee2-0c0adca4040d/wKiom1U1xMqSoMTtAABsGbvee8g521.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CoAP是受限制的应用协议(Constrained Application Protocol)的代名词。在当前由PC机组成的世界，交换是通过TCP和应用层协议HTTP实现的。但是对于小型设备而言，实现TCP和HTTP协议显然是一个过分的要求。为了让小设备可以接入，CoAP协
      
    
    </summary>
    
      <category term="物联网" scheme="https://deflin.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="CoAP" scheme="https://deflin.github.io/tags/CoAP/"/>
    
      <category term="网络协议" scheme="https://deflin.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读代码</title>
    <link href="https://deflin.github.io/2018/06/06/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/"/>
    <id>https://deflin.github.io/2018/06/06/如何阅读代码/</id>
    <published>2018-06-06T13:07:04.339Z</published>
    <updated>2018-06-10T07:09:01.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="收集所有可能收集的材料"><a href="#收集所有可能收集的材料" class="headerlink" title="收集所有可能收集的材料"></a>收集所有可能收集的材料</h3><p>阅读代码要做的第一件事情是收集所有和项目相关的资料。比如你要做一个项目的售后服务，那么你首先要搞明白项目做什么用的，那么调研文档、概要设计文档、详细设计文档、测试文档、使用手册都是你要最先搞到手的。如果你是为了学习那么尽量收集和你的学习有关的资料，比如你想学习Linux的文件系统的代码，那最好要找到linux的使用手册、以及文件系统设计的方法、数据结构的说明。(这些资料在书店里都可以找到)。</p><h3 id="材料的种类分为几种类型"><a href="#材料的种类分为几种类型" class="headerlink" title="材料的种类分为几种类型"></a>材料的种类分为几种类型</h3><h4 id="1-基础资料。"><a href="#1-基础资料。" class="headerlink" title="1.基础资料。"></a>1.基础资料。</h4><p>比如你阅读turbo c2的源代码你要有turbo c2的函数手册，使用手册等专业书籍，msc 6.0或者Java 的话不但要有函数手册，还要有类库函数手册。这些资料都是你的基础资料。另外你要有一些关于uml的资料可以作为查询手册也是一个不错的选择。</p><h4 id="2-和程序相关的专业资料。"><a href="#2-和程序相关的专业资料。" class="headerlink" title="2.和程序相关的专业资料。"></a>2.和程序相关的专业资料。</h4><p>　　每一个程序都是和相关行业相关的。比如我阅读过一个关于气象分析方面的代码，因为里边用到了一个复杂的数据转换公式，所以不得不把自己的大学时候课本 找出来来复习一下高等数学的内容。如果你想阅读linux的文件管理的代码，那么找一本讲解linux文件系统的书对你的帮助会很大。</p><h4 id="3-相关项目的文档资料"><a href="#3-相关项目的文档资料" class="headerlink" title="3.相关项目的文档资料"></a>3.相关项目的文档资料</h4><p>　　这一部分的资料分为两种，一个相关行业的资料，比如你要阅读一个税务系统的代码那么有一些财务/税务系统的专业资料和国家的相关的法律、法规的资料是 必不可少的。此外就是关于这个项目的需求分析报告、概要设计报告、详细设计报告，使用手册、测试报告等，尽量多收集对你以后的代码阅读是很重要的</p><h3 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h3><p>　　了解基础知识，不要上来就阅读代码，打好基础可以做到事半功倍的效果</p><p>　　留备份,构造可运行的环境</p><p>　　代码拿到手之后的第一件事情是先做备份，最好是刻在一个光盘上，在代码阅读的时候一点不动代码是很困难的一件事情，特别是你要做一些修改性或增强性维护的时候。而一旦做修改就可能发生问题，到时候要恢复是经常发生的事情，如果你不能很好的使用版本控制软件那么先留一个备份是一个最起码的要求了。</p><p>　　在做完备份之后最好给自己构造一个可运行的环境，当然可能会很麻烦，但可运行代码和不可运行的代码阅读起来难度会差很多的。所以多用一点时间搭建一个环境是很值得的，而且我们阅读代码主要是为了修改其中的问题或做移植操作。不能运行的代码除了可以学到一些技术以外，用处有限。<br>　　找开始的地方</p><p>　　做什么事情都要知道从那里开始，读程序也不例外。在C语言里,首先要找到main()函数，然后逐层去阅读，其他的程序无论是vb、delphi都要首先找到程序头，否则你是很难分析清楚程序的层次关系。</p><h3 id="分层次阅读"><a href="#分层次阅读" class="headerlink" title="分层次阅读"></a>分层次阅读</h3><p>　　在阅读代码的时候不要一头就扎下去，这样往往容易只见树木不见森林，阅读代码比较好的方法有一点象二叉树的广度优先的遍历。在程序主体一般会比较简 单，调用的函数会比较少，根据函数的名字以及层次关系一般可以确定每一个函数的大致用途，将你的理解作为注解写在这些函数的边上。当然很难一次就将全部注 解都写正确，有时候甚至可能是你猜测的结果，不过没有关系这些注解在阅读过程是不断修正的，直到你全部理解了代码为止。一般来说采用逐层阅读的方法可以是 你系统的理解保持在一个正确的方向上。避免一下子扎入到细节的问题上。在分层次阅读的时候要注意一个问题，就是将系统的函数和开发人员编写代码区分开。在 c, c++，java ,delphi中都有自己的系统函数，不要去阅读这些系统函数，除非你要学习他们的编程方法，否则只会浪费你的时间。将系统函数表示出来，注明它们的作用 即可，区分系统函数和自编函数有几个方法，一个是系统函数的编程风格一般会比较好，而自编的函数的编程风格一般比较会比较差。从变量名、行之间的缩进、注 解等方面一般可以分辨出来，另外一个是像ms c6++会在你编程的时候给你生成一大堆文件出来，其中有很多文件是你用不到了，可以根据文件名来区分一下时候是系统函数，最后如果你实在确定不了，那就 用开发系统的帮助系统去查一下函数名，对一下参数等来确定即可。</p><h3 id="写注解"><a href="#写注解" class="headerlink" title="写注解"></a>写注解</h3><p>　　写注解是在阅读代码中最重要的一个步骤，在我们阅读的源代码一般来说是我们不熟悉的系统,阅读别人的代码一般会有几个问题：<br>1、搞明白别人的编程思想不 是一件很容易的事情，即使你知道这段程序的思路的时候也是一样。<br>2、阅读代码的时候代码量一般会比较大，如果不及时写注解往往会造成读明白了后边忘了前边的 现象。<br>3、阅读代码的时候难免会出现理解错误，如果没有及时的写注解很难及时的发现这些错误。<br>4、不写注解有时候你发现你很难确定一个函数你什么时候阅读过，它的功能是什么，经常会发生重复阅读、理解的现象。</p><p>好了，说一些写注解的基本方法：<br>1、猜测的去写，刚开始阅读一个代码的时候，你很难一下子就确定所有的函数的功能，不妨采用采用猜测的方法去写注解，根据函数的名字、位置写一个大致的注解，当然一般会有错误，但你的注解实际是不断调整的，直到最后你理解了全部代码。<br>2、按功能去写，别把注解写成语法说明书，千万别看到fopen就写打开文件，看到fread就写读数据，这样的注解一点用处都没有，而应该写“在此处开发参数配置文件(<em>**</em>.dat)”、“读出系统初始化参数……”这样才是有用的注解。<br>3、在写注解的使用另外要注意的一个问题是分清楚系统自动生成的代码和用户自己开发的代码，一般来说没有必要写系统自动生成的代码。象delphi的代码，我们往往要自己编写一些自己的代码段，还要对一些系统自动生成的代码段进行修改，这些代码在阅读过程是要写注解的，但有一些没有修改过的自动生成的代码就没有必要写注解了。<br>4、在主要代码段要写较为详细的注解。有一些函数或类在程序中起关键的作用，那么要写比较详细的注解。这样对你理解代码有很大的帮助。<br>5、对你理解起来比较困难的地方要写详细的注解，在这些地方往往会有一些编程的技巧。不理解这些编程技巧对你以后的理解或移植会有问题。<br>6、写中文注解。如果你的英文足够的好，不用看这条了，但很多的人英文实在不怎么样，那就写中文注解吧，我们写注解是为了加快自己的理解速度。中文在大多数的时候比英文更适应中国人。与其写一些谁也看不懂的英文注解还不如不写。</p><h3 id="重复阅读"><a href="#重复阅读" class="headerlink" title="重复阅读"></a>重复阅读</h3><p>　　一次就可以将所有的代码都阅读明白的人是没有的。至少我还没有遇到过。反复的去阅读同一段代码有助于对代码的理解。一般来说，在第一次阅读代码的时候 你可以跳过很多一时不明白的代码段，只写一些简单的注解，在以后的重复阅读过程中用，你对代码的理解会比上一次理解的更深刻，这样你可以修改那些注解错误的地方和上一次没有理解的地方。一般来说，对代码阅读3，4次基本可以理解代码的含义和作用。</p><h3 id="运行并修改代码"><a href="#运行并修改代码" class="headerlink" title="运行并修改代码"></a>运行并修改代码</h3><p>　　如果你的代码是可运行的，那么先让它运行起来，用单步跟踪的方法来阅读代码，会提高你的代码速度。代码通过看中间变量了解代码的含义,而且对以后的修改会提供很大的帮助。<br>　　用自己的代码代替原有代码，看效果，但在之前要保留源代码。<br>　　600行的一个函数，阅读起来很困难，编程的人不是一个好的习惯。在阅读这个代码的时候将代码进行修改，变成了14个函数。每一个大约是40-50行左右。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;收集所有可能收集的材料&quot;&gt;&lt;a href=&quot;#收集所有可能收集的材料&quot; class=&quot;headerlink&quot; title=&quot;收集所有可能收集的材料&quot;&gt;&lt;/a&gt;收集所有可能收集的材料&lt;/h3&gt;&lt;p&gt;阅读代码要做的第一件事情是收集所有和项目相关的资料。比如你要做一个项
      
    
    </summary>
    
      <category term="程序员生涯" scheme="https://deflin.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E6%B6%AF/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>基于CC3200实现WiFi Direct</title>
    <link href="https://deflin.github.io/2018/06/05/%E5%9F%BA%E4%BA%8ECC3200%E5%AE%9E%E7%8E%B0WiFi%20Direct/"/>
    <id>https://deflin.github.io/2018/06/05/基于CC3200实现WiFi Direct/</id>
    <published>2018-06-05T14:18:25.303Z</published>
    <updated>2018-06-06T11:57:37.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遇到的问题与解决"><a href="#遇到的问题与解决" class="headerlink" title="遇到的问题与解决"></a>遇到的问题与解决</h1><p>没接触过这类板子，有点陌生，不要紧，一步一步来。<br>问题一：<br>1.烧写了官方的SDK，按照提示，通过WiFi直连连接到了手机，但是失败概率很高，使用华为P10和魅蓝5连接不上，换用华为Nova2可以较为轻松的连上，暂时不知道是什么原因。<br>2.在网上下载了几个APP：serial WiFi，WiFi TCP/UDP，可以连接到cc3200，但是无法数据通信。想知道是否需要TI官方相关的配套APP才可以。          </p><p>解决一：<br>下载了个APP“magic iperf”,好像是有了点作用，串口打印出已经收到TCP数据，然而没有打印出接收到的数据啊。</p><p>问题二：<br>修改了程序，输出了接收缓冲区，但是输出的内容让人摸不着头脑。怎么看都不像是正常的数据包。现在最大的问题，应该怎样通过手机给模块发送TCP数据，并且通过串口打印输出到电脑上。代码里面找不到相关的内容，只有socket的创建，绑定端口等操作，在一个叫“BsdTcpServer”的函数里。这个函数，跟一般的建立一个TCP sever的基本思路大同小异，那么讲道理，TCP的接收数据的接口应该就是“sl_Recv”此类的函数，难道这个函数的参数“uBuf.BsdBuf”不是用于存放TCP数据包的吗？<br>现在大致的思路应该是，使用串口中断，将接收到的数据，通过TCP的这个接口函数，发送到移动终端，就好了吧。</p><p>解决二：<br>问题解决了，其实一直都是通的，但是这个官方的demo并没有将接收到的数据打印出来，仅仅是做了一个接收判断（即接收到数据后就亮一盏灯，然后打印出接收成功的字样）。另外，想要向手机端发送数据需要调用”sl_Send”函数，使用方式与“ sl_Recv ”类似。</p><p>问题三：<br>现在的现象有点奇怪，两个情况下WiFi模块会无法连接：<br>1.将开关拨到与WiFi模块相连，插上dongle，WiFi无法连接。另外，此时将开关拨到另一边，也不能连接WiFi。只有单独将WiFi模块复位才行。<br>2.在连接上之后，发送AT+NRB，会导致WiFi断开，并再无法连接。解决办法同上，也是要将WiFi模块复位才行。<br>根据以上现象来看，似乎是WiFi跟NB模组连接的串口导致。但是什么样的串口问题会导致这种情况呢？</p><p>解决三：<br>以上出现的现象原来是因为跟WiFi相连的另一路串口没有配置导致的，与NB模块LOGVIEW口相连的UART0串口，会在NB模块启动的时候收到log数据，导致WiFi模块卡死。为什么会卡死，我还不太明白，为什么没有配置的串口收到数据会导致程序卡死。</p><p>导致模块复位的原因知道了，是程序里的一个复位Pin脚占用了UART0的串口。</p><p>问题四：<br>虽然配置好了两路的串口，但是发现，在收发AT命令的时候，两路串口好像会有干扰，导致收到的数据是乱码。之所以会这么觉得，是以为屏蔽了另一路串口问题就解决了。UART0的配置如下：<br>1.引脚配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void PinMuxConfig(void)</span><br><span class="line">&#123;</span><br><span class="line">    // Enable Peripheral Clocks</span><br><span class="line">    MAP_PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK);</span><br><span class="line"></span><br><span class="line">    MAP_PinTypeUART(PIN_03, PIN_MODE_7);//UART0</span><br><span class="line"></span><br><span class="line">    MAP_PinTypeUART(PIN_04, PIN_MODE_7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.串口属性配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void LOGVIEWComPort_Init_921600(void)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">   MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8);</span><br><span class="line">   MAP_UARTFIFOEnable(COM_P0);</span><br><span class="line">   MAP_UARTFlowControlSet(COM_P0, UART_FLOWCONTROL_NONE);</span><br><span class="line">  </span><br><span class="line">   MAP_UARTConfigSetExpClk(COM_P0,MAP_PRCMPeripheralClockGet(COM_P0_PERIPH),</span><br><span class="line">                            921600, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |</span><br><span class="line">                                             UART_CONFIG_PAR_NONE));</span><br><span class="line">   MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler);</span><br><span class="line">   MAP_IntPrioritySet(INT_UARTA0,INT_PRIORITY_LVL_0);</span><br><span class="line">   MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待解决四：<br>进一步尝试，发现是这几句话会导致串口干扰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8);</span><br><span class="line">    MAP_UARTFIFOEnable(COM_P0);</span><br><span class="line">    MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler);</span><br><span class="line">    MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">解决四：</span><br><span class="line"></span><br><span class="line">问题原因是没有处理中断接收的数据，导致的干扰，配置好中断的处理函数之后就没有这样的问题了，不是以上这几条语句导致的。</span><br><span class="line"></span><br><span class="line">问题五：</span><br><span class="line">socket的数据流程整理了一下，数据结构挺庞大，好在还算清晰。简单的流程如下图：</span><br><span class="line"></span><br><span class="line">![] (https://app.yinxiang.com/shard/s62/res/14408816-1d63-434e-9576-39a18458d2c2)</span><br><span class="line"></span><br><span class="line">然后，数据是怎样从串口传到socket的呢？貌似是通过全局的队列，就是下面的这个函数，在UART的接收中断中执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line"></span><br><span class="line">void uart_get_char(char c)</span><br><span class="line">&#123;</span><br><span class="line">    char flag = 0;</span><br><span class="line">    portBASE_TYPE xHigherPriorityTaskWoken;</span><br><span class="line">    uart_timer_stop();</span><br><span class="line">    lps_event_timer = 0;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len_queue(&amp;g_p_uart_buf-&gt;queue) == UART_FRAME_MAX_LEN - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">    &#125;</span><br><span class="line">//队列满的情况计数，这部分代码可以复用</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (full_quene(&amp;g_p_uart_buf-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        uart_bug_count++;   //计数用来测试串口数据满的情况</span><br><span class="line">        Report(<span class="string">"full_quene\r\n"</span>);</span><br><span class="line">        LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"full_quene\r\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;lostNew) //丢弃最新的数据</span><br><span class="line">        &#123;</span><br><span class="line">            g_uart_to_sock_cnt++;       </span><br><span class="line">            portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            g_p_uart_buf-&gt;queue.rear = (g_p_uart_buf-&gt;queue.rear + 1) % QUEUE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (g_p_uart_buf-&gt;tmodeState == TMODE_CMD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)  //有些命令以\r\n结束</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里把串口收的数据放到这里</span><br><span class="line">    en_queue(&amp;g_p_uart_buf-&gt;queue, c);</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        g_uart_to_sock_cnt++;</span><br><span class="line">        portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;tmodeState == TMODE_CMD)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_p_uart_buf-&gt;<span class="built_in">echo</span> == ECHO_ON)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">'\r'</span> != c)</span><br><span class="line">                &#123;</span><br><span class="line">                    uart_output_byte(COM_P1, c);</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\b'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                de_queue_font(&amp;g_p_uart_buf-&gt;queue);    // delete <span class="string">'\b'</span></span><br><span class="line">                de_queue_font(&amp;g_p_uart_buf-&gt;queue);    // delete <span class="string">'previous'</span></span><br><span class="line">                uart_output_byte(COM_P1, <span class="string">' '</span>);</span><br><span class="line">                uart_output_byte(COM_P1, <span class="string">'\b'</span>);</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\r'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                g_uart_to_at_cnt++;</span><br><span class="line">                portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            uart_timer_start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上存储数据的操作之后，将队列中的数据存到socket的数组中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">void uart_recv_task(void *argc)</span><br><span class="line">&#123;</span><br><span class="line">    uartParaStruct *pUartPara = (uartParaStruct *)argc;</span><br><span class="line">    threadParaStruct *pThreadPara = pUartPara-&gt;para;</span><br><span class="line">    uartBuf_typeDef *pBuf = l_v_uart_buf;</span><br><span class="line">    char *pBufAt = NULL;</span><br><span class="line">  </span><br><span class="line">    unsigned short pos;</span><br><span class="line">    int i;</span><br><span class="line">    char existSock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pThreadPara-&gt;threadCompleted)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((l_uart_to_sock_cnt &gt; 0))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l_uart_to_sock_cnt &gt; 3)</span><br><span class="line">            &#123;</span><br><span class="line">                l_uart_to_sock_cnt = 3;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pBuf-&gt;queue.font;</span><br><span class="line"></span><br><span class="line">            // 从串口buffer中取出数据</span><br><span class="line">            // 若无网络task，可以使用串口接受callback</span><br><span class="line">            // 故每次直接从队列中取出数据，且tempbuf清楚</span><br><span class="line">            pBuf-&gt;tempBufLen = 0;</span><br><span class="line">            memset(pBuf-&gt;tempBuf, 0, sizeof(pBuf-&gt;tempBuf));</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (empty_quene(&amp;pBuf-&gt;queue))</span><br><span class="line">                &#123;</span><br><span class="line">                    l_uart_to_sock_cnt = 0;</span><br><span class="line">         </span><br><span class="line">                    uart_debug(<span class="string">"The uart queue is empty,need check code\n"</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt;= UART_FRAME_MAX_LEN)</span><br><span class="line">                &#123;</span><br><span class="line">          </span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                de_queue(&amp;pBuf-&gt;queue, &amp;pBuf-&gt;tempBuf[pBuf-&gt;tempBufLen]);</span><br><span class="line">                pBuf-&gt;tempBufLen++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">while</span> (pos != pBuf-&gt;queue.rear);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //uart callback</span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;recv_callback)</span><br><span class="line">                &#123;</span><br><span class="line">                    pBuf-&gt;tempBufLen = pBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_REDAY, (void *)pBuf, pBuf-&gt;tempBuf, pBuf-&gt;tempBufLen);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //still have data,send quene to net task</span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    existSock = 0;</span><br><span class="line">                    <span class="keyword">if</span> (g_sock_used[1] == TRUE) //当前sock建立</span><br><span class="line">                    &#123;</span><br><span class="line">    </span><br><span class="line">                      pBuf-&gt;sockSendLen[1] = pBuf-&gt;tempBufLen;</span><br><span class="line">                      existSock = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (existSock)</span><br><span class="line">                    &#123;</span><br><span class="line">                        msleep(_DELAY_SWITCH_CONTEXT_MS); // 任务挂起，让给高优先级的sock</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        existSock = 0;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> ((g_sock_used[1] == TRUE) &amp;&amp; (g_sock_tcp[1] == TRUE))</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="keyword">if</span> (pBuf-&gt;sockSendLen[1] &gt; 0) //  1</span><br><span class="line">                          &#123;</span><br><span class="line">                            existSock = 1;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (existSock)</span><br><span class="line">                        &#123;</span><br><span class="line">                            msleep(_DELAY_FOR_WAIT_SOCK);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l_uart_to_sock_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l_uart_to_sock_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            msleep(30);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，在socket的任务中会检测是否有数据存在，有的话就通过接口函数发送到网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">//如果接收到了数据</span><br><span class="line">      <span class="keyword">if</span> (g_p_uart_buf != NULL)</span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT)</span><br><span class="line">        &#123;</span><br><span class="line">          int send_len = g_p_uart_buf-&gt;sockSendLen[id];</span><br><span class="line">          //socka_debug(<span class="string">"uart recv data\r\n"</span>);</span><br><span class="line">          //socka_debug(<span class="string">"id=%d\r\n"</span>, id);</span><br><span class="line">          start_time = xTaskGetTickCount();   // 获取ejoin 开始时间</span><br><span class="line">          //<span class="keyword">if</span>(strlen(g_p_uart_buf-&gt;tempBuf))</span><br><span class="line">          </span><br><span class="line">          ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0);</span><br><span class="line">          first_time = xTaskGetTickCount();</span><br><span class="line">          LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"(%d,%u)\r\n"</span>, first_time-start_time, start_time);</span><br><span class="line">          <span class="keyword">if</span> ((ret &lt; 0)  || (ret == 0))</span><br><span class="line">          &#123;</span><br><span class="line">            socka_debug(<span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            sock_fd = -1;</span><br><span class="line">            </span><br><span class="line">            pThreadPara-&gt;threadCompleted = TRUE;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (send_len != ret)      //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了</span><br><span class="line">          &#123;</span><br><span class="line">            //网络未正常断开的时候，不能用send检测到</span><br><span class="line">            //这里发送失败就选择重新发送，接收的select中会检测到断网</span><br><span class="line">            //socka_debug(<span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (reSendTimers++ &gt; NET_RECONNECT_TIMES)   // 丢弃数据</span><br><span class="line">            &#123;</span><br><span class="line">              //reSendTimers = reSendTimers;</span><br><span class="line">              g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              msleep(20);</span><br><span class="line">              <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          needSleep = 0;</span><br><span class="line">          reSendTimers = 0;</span><br><span class="line">          g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(NULL != pNetBuf-&gt;recv_callback)  // 150423</span><br><span class="line">          &#123;</span><br><span class="line">            pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          //          socka_debug(<span class="string">"uart not recvd, wait...\r\n"</span>);</span><br><span class="line">          osi_Sleep(10);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">//如果接收到了数据</span><br><span class="line">      <span class="keyword">if</span> (g_p_uart_buf != NULL)</span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT)</span><br><span class="line">        &#123;</span><br><span class="line">          int send_len = g_p_uart_buf-&gt;sockSendLen[id];</span><br><span class="line">          //socka_debug(<span class="string">"uart recv data\r\n"</span>);</span><br><span class="line">          //socka_debug(<span class="string">"id=%d\r\n"</span>, id);</span><br><span class="line">          start_time = xTaskGetTickCount();   // 获取ejoin 开始时间</span><br><span class="line">          //<span class="keyword">if</span>(strlen(g_p_uart_buf-&gt;tempBuf))</span><br><span class="line">          </span><br><span class="line">          ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0);</span><br><span class="line">          first_time = xTaskGetTickCount();</span><br><span class="line">          LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"(%d,%u)\r\n"</span>, first_time-start_time, start_time);</span><br><span class="line">          <span class="keyword">if</span> ((ret &lt; 0)  || (ret == 0))</span><br><span class="line">          &#123;</span><br><span class="line">            socka_debug(<span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            sock_fd = -1;</span><br><span class="line">            </span><br><span class="line">            pThreadPara-&gt;threadCompleted = TRUE;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (send_len != ret)      //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了</span><br><span class="line">          &#123;</span><br><span class="line">            //网络未正常断开的时候，不能用send检测到</span><br><span class="line">            //这里发送失败就选择重新发送，接收的select中会检测到断网</span><br><span class="line">            //socka_debug(<span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (reSendTimers++ &gt; NET_RECONNECT_TIMES)   // 丢弃数据</span><br><span class="line">            &#123;</span><br><span class="line">              //reSendTimers = reSendTimers;</span><br><span class="line">              g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              msleep(20);</span><br><span class="line">              <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          needSleep = 0;</span><br><span class="line">          reSendTimers = 0;</span><br><span class="line">          g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(NULL != pNetBuf-&gt;recv_callback)  // 150423</span><br><span class="line">          &#123;</span><br><span class="line">            pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          //          socka_debug(<span class="string">"uart not recvd, wait...\r\n"</span>);</span><br><span class="line">          osi_Sleep(10);</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>现在遇到的麻烦是，开启sockB的时候，会导致堆栈溢出。</p><p>很好，堆栈溢出的问题解决了，原因是任务分配的内存大小不够，sockB的任务。</p><p>然而，新的问题又出现了，使用sockB无法连接。</p><p>最新问题，当数据大于等于512个字节时，队列的缓冲区就满了，很奇怪，明明分配了0x1600的空间，却用不到那么空间。</p><p>解决五：</p><p>上述问题都解决了，但实际上还遗留着一个问题，就是使用socketB作为lowview的数据通道时，串口中断的队列会溢出。现在的做法是，将socketB换成了AT命令的数据通道。问题得以规避。原因却没有找到，大概是socketB发送数据时出队的设计这边有些问题，支撑不了这么快的数据。</p><p>问题六：</p><p>AT串口出现断包的现象，想想是什么原因吧，可是NB模块又是返回正确的数据长度以及OK，然而服务器那边却收不到断了的数据包。这是为什么？<br>明天早上先把串口换一下试试。</p><p>解决六：</p><p>接收断包的现象可能跟WiFi模块的信号有关，使用手机做热点的时候并不会有这种现象，并且，这现象只发生在模块刚启动的一会儿，过一会就不再有这种情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;遇到的问题与解决&quot;&gt;&lt;a href=&quot;#遇到的问题与解决&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题与解决&quot;&gt;&lt;/a&gt;遇到的问题与解决&lt;/h1&gt;&lt;p&gt;没接触过这类板子，有点陌生，不要紧，一步一步来。&lt;br&gt;问题一：&lt;br&gt;1.烧写了官方的SD
      
    
    </summary>
    
      <category term="CC32xx系列开发" scheme="https://deflin.github.io/categories/CC32xx%E7%B3%BB%E5%88%97%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CC3200" scheme="https://deflin.github.io/tags/CC3200/"/>
    
      <category term="单片机" scheme="https://deflin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="WiFi" scheme="https://deflin.github.io/tags/WiFi/"/>
    
  </entry>
  
  <entry>
    <title>va_start和va_end使用详解</title>
    <link href="https://deflin.github.io/2018/06/01/va_start%E5%92%8Cva_end%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://deflin.github.io/2018/06/01/va_start和va_end使用详解/</id>
    <published>2018-06-01T03:21:52.155Z</published>
    <updated>2018-06-05T11:53:49.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表</p><p>void foo(…);<br>void foo(parm_list,…);<br>这种方式和我们以前认识的不大一样，但我们要记住这是C中一种传参的形式，在后面我们就会用到它。</p><p>2.函数参数的传递原理<br>　　函数参数是以数据结构:栈的形式存取,从右至左入栈。</p><p>　　首先是参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址，举个例子如下：<br>void func(int x, float y, char z);<br>　　那么，调用函数的时候，实参 char z 先进栈，然后是 float y，最后是 int x，因此在内存中变量的存放次序是 x-&gt;y-&gt;z，因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过指针移位运算，则总可以顺藤摸瓜找到其他的输入变量。</p><p>　　下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：<br>typedef char<em> va_list;<br>void va_start ( va_list ap, prev_param ); /</em> ANSI version */<br>type va_arg ( va_list ap, type );<br>void va_end ( va_list ap );<br>va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。</p><p><step 1=""> 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</step></p><p><step 2=""> 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数；</step></p><p><step 3=""> 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；</step></p><p><step 4=""> 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。</step></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream.h&gt; void fun(int a, ...) &#123; 　　int *temp = &amp;a;　　temp++;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">for</span> (int i = 0; i &lt; a; ++i) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　cout &lt;&lt; *temp &lt;&lt; endl; </span><br><span class="line">　　　　temp++; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">　　int a = 1; </span><br><span class="line">　　int b = 2; </span><br><span class="line">　　int c = 3; </span><br><span class="line">　　int d = 4; </span><br><span class="line">　　fun(4, a, b, c, d); </span><br><span class="line">　　system(<span class="string">"pause"</span>); </span><br><span class="line">　　<span class="built_in">return</span> 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Output:: </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>3:获取省略号指定的参数<br>　　在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。像这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void TestFun(char* pszDest, int DestLen, const char* pszFormat, ...) &#123; va_list args; va_start(args, pszFormat); //一定要“...”之前的那个参数_vsnprintf(pszDest, DestLen, pszFormat, args); va_end(args); &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4.演示如何使用参数个数可变的函数，采用ANSI标准形式 </span><br><span class="line"><span class="comment">#include 〈stdio.h〉 </span></span><br><span class="line"><span class="comment">#include 〈string.h〉 </span></span><br><span class="line"><span class="comment">#include 〈stdarg.h〉 </span></span><br><span class="line"></span><br><span class="line">/*函数原型声明，至少需要一个确定的参数，注意括号内的省略号*/ </span><br><span class="line">int demo( char, ... ); </span><br><span class="line">void main( void ) </span><br><span class="line">&#123; </span><br><span class="line">   demo(<span class="string">"DEMO"</span>, <span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"demo!"</span>, <span class="string">""</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*ANSI标准形式的声明方式，括号内的省略号表示可选参数*/ </span><br><span class="line">int demo( char msg, ... ) </span><br><span class="line">&#123; </span><br><span class="line">       /*定义保存函数参数的结构*/</span><br><span class="line">   va_list argp; </span><br><span class="line">   int argno = 0; </span><br><span class="line">   char para; </span><br><span class="line">　　   /*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/ </span><br><span class="line">   va_start( argp, msg ); </span><br><span class="line">   <span class="keyword">while</span> (1) </span><br><span class="line">       &#123; </span><br><span class="line">        para = va_arg( argp, char); </span><br><span class="line">           <span class="keyword">if</span> ( strcmp( para, <span class="string">""</span>) == 0 ) </span><br><span class="line">               <span class="built_in">break</span>; </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"Parameter #%d is: %s\n"</span>, argno, para); </span><br><span class="line">           argno++; </span><br><span class="line">&#125; </span><br><span class="line">va_end( argp ); </span><br><span class="line">/*将argp置为NULL*/</span><br><span class="line"><span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表&lt;/p&gt;
&lt;p&gt;void foo(…);&lt;br&gt;void 
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>可变参数函数用法</title>
    <link href="https://deflin.github.io/2018/05/30/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <id>https://deflin.github.io/2018/05/30/可变参数函数用法/</id>
    <published>2018-05-30T13:26:12.694Z</published>
    <updated>2018-06-05T11:54:13.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>typedef char* va_list;//用于声明一个指向参数列表的字符型指针变量<br>void va_start(va_list ap,prev_param);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的第一个参数，通常用于指定可变参数列表中参数的个数<br>void va_arg(va_list ap,type);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的数据类型<br>void va_end(va_list ap);//将存放可变参数字符串的变量清空（赋值为NULL）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int sum(int count,...)//计算和</span><br><span class="line">&#123;</span><br><span class="line">     int sum = 0;</span><br><span class="line">     int i;</span><br><span class="line">     va_list ap;</span><br><span class="line">     va_start(ap,count);</span><br><span class="line">     <span class="keyword">for</span>(i=0;i&lt;count;++i)</span><br><span class="line">     &#123;</span><br><span class="line">          sum+=va_arg(ap,int);</span><br><span class="line">     &#125;</span><br><span class="line">     va_end(ap);</span><br><span class="line">     <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>,sum(3,1,2,3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;example&quot;&gt;&lt;a href=&quot;#example&quot; class=&quot;headerlink&quot; title=&quot;example&quot;&gt;&lt;/a&gt;example&lt;/h2&gt;&lt;p&gt;typedef char* va_list;//用于声明一个指向参数列表的字符型指针变量&lt;br&gt;vo
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>关于回调函数的理解</title>
    <link href="https://deflin.github.io/2018/05/26/%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://deflin.github.io/2018/05/26/关于回调函数的理解/</id>
    <published>2018-05-26T14:07:01.285Z</published>
    <updated>2018-06-05T11:54:02.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p><p>实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。</p><p>populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdlib.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line">// 回调函数 </span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span> (size_t i=0; i&lt;arraySize; i++) </span><br><span class="line">        array[i] = getNextValue(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 获取随机值 </span><br><span class="line">int getNextRandomValue(void) &#123; </span><br><span class="line"></span><br><span class="line">     <span class="built_in">return</span> rand(); </span><br><span class="line">&#125; </span><br><span class="line">int main(void) </span><br><span class="line">&#123; </span><br><span class="line">    int myarray[10];</span><br><span class="line"></span><br><span class="line">//此处getNextValue指向 getNextRandomValue函数的地址，起到调用作用</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, myarray[i]); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">    <span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;example&quot;&gt;&lt;a href=&quot;#example&quot; class=&quot;headerlink&quot; title=&quot;example&quot;&gt;&lt;/a&gt;example&lt;/h2&gt;&lt;p&gt;实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
