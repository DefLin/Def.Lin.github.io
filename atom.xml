<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林定益想去NASA捡垃圾</title>
  
  <subtitle>Stay hungry,Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://deflin.github.io/"/>
  <updated>2018-06-09T07:16:08.305Z</updated>
  <id>https://deflin.github.io/</id>
  
  <author>
    <name>Def Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何阅读代码</title>
    <link href="https://deflin.github.io/2018/06/06/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/"/>
    <id>https://deflin.github.io/2018/06/06/如何阅读代码/</id>
    <published>2018-06-06T13:07:04.339Z</published>
    <updated>2018-06-09T07:16:08.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="收集所有可能收集的材料"><a href="#收集所有可能收集的材料" class="headerlink" title="收集所有可能收集的材料"></a>收集所有可能收集的材料</h3><p>阅读代码要做的第一件事情是收集所有和项目相关的资料。比如你要做一个项目的售后服务，那么你首先要搞明白项目做什么用的，那么调研文档、概要设计文档、详细设计文档、测试文档、使用手册都是你要最先搞到手的。如果你是为了学习那么尽量收集和你的学习有关的资料，比如你想学习Linux的文件系统的代码，那最好要找到linux的使用手册、以及文件系统设计的方法、数据结构的说明。(这些资料在书店里都可以找到)。</p><h3 id="材料的种类分为几种类型"><a href="#材料的种类分为几种类型" class="headerlink" title="材料的种类分为几种类型"></a>材料的种类分为几种类型</h3><h4 id="1-基础资料。"><a href="#1-基础资料。" class="headerlink" title="1.基础资料。"></a>1.基础资料。</h4><p>比如你阅读turbo c2的源代码你要有turbo c2的函数手册，使用手册等专业书籍，msc 6.0或者Java 的话不但要有函数手册，还要有类库函数手册。这些资料都是你的基础资料。另外你要有一些关于uml的资料可以作为查询手册也是一个不错的选择。</p><h4 id="2-和程序相关的专业资料。"><a href="#2-和程序相关的专业资料。" class="headerlink" title="2.和程序相关的专业资料。"></a>2.和程序相关的专业资料。</h4><p>　　每一个程序都是和相关行业相关的。比如我阅读过一个关于气象分析方面的代码，因为里边用到了一个复杂的数据转换公式，所以不得不把自己的大学时候课本 找出来来复习一下高等数学的内容。如果你想阅读linux的文件管理的代码，那么找一本讲解linux文件系统的书对你的帮助会很大。</p><h4 id="3-相关项目的文档资料"><a href="#3-相关项目的文档资料" class="headerlink" title="3.相关项目的文档资料"></a>3.相关项目的文档资料</h4><p>　　这一部分的资料分为两种，一个相关行业的资料，比如你要阅读一个税务系统的代码那么有一些财务/税务系统的专业资料和国家的相关的法律、法规的资料是 必不可少的。此外就是关于这个项目的需求分析报告、概要设计报告、详细设计报告，使用手册、测试报告等，尽量多收集对你以后的代码阅读是很重要的</p><h3 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h3><p>　　了解基础知识，不要上来就阅读代码，打好基础可以做到事半功倍的效果</p><p>　　留备份,构造可运行的环境</p><p>　　代码拿到手之后的第一件事情是先做备份，最好是刻在一个光盘上，在代码阅读的时候一点不动代码是很困难的一件事情，特别是你要做一些修改性或增强性维护的时候。而一旦做修改就可能发生问题，到时候要恢复是经常发生的事情，如果你不能很好的使用版本控制软件那么先留一个备份是一个最起码的要求了。</p><p>　　在做完备份之后最好给自己构造一个可运行的环境，当然可能会很麻烦，但可运行代码和不可运行的代码阅读起来难度会差很多的。所以多用一点时间搭建一个环境是很值得的，而且我们阅读代码主要是为了修改其中的问题或做移植操作。不能运行的代码除了可以学到一些技术以外，用处有限。<br>　　找开始的地方</p><p>　　做什么事情都要知道从那里开始，读程序也不例外。在C语言里,首先要找到main()函数，然后逐层去阅读，其他的程序无论是vb、delphi都要首先找到程序头，否则你是很难分析清楚程序的层次关系。</p><h3 id="分层次阅读"><a href="#分层次阅读" class="headerlink" title="分层次阅读"></a>分层次阅读</h3><p>　　在阅读代码的时候不要一头就扎下去，这样往往容易只见树木不见森林，阅读代码比较好的方法有一点象二叉树的广度优先的遍历。在程序主体一般会比较简 单，调用的函数会比较少，根据函数的名字以及层次关系一般可以确定每一个函数的大致用途，将你的理解作为注解写在这些函数的边上。当然很难一次就将全部注 解都写正确，有时候甚至可能是你猜测的结果，不过没有关系这些注解在阅读过程是不断修正的，直到你全部理解了代码为止。一般来说采用逐层阅读的方法可以是 你系统的理解保持在一个正确的方向上。避免一下子扎入到细节的问题上。在分层次阅读的时候要注意一个问题，就是将系统的函数和开发人员编写代码区分开。在 c, c++，java ,delphi中都有自己的系统函数，不要去阅读这些系统函数，除非你要学习他们的编程方法，否则只会浪费你的时间。将系统函数表示出来，注明它们的作用 即可，区分系统函数和自编函数有几个方法，一个是系统函数的编程风格一般会比较好，而自编的函数的编程风格一般比较会比较差。从变量名、行之间的缩进、注 解等方面一般可以分辨出来，另外一个是像ms c6++会在你编程的时候给你生成一大堆文件出来，其中有很多文件是你用不到了，可以根据文件名来区分一下时候是系统函数，最后如果你实在确定不了，那就 用开发系统的帮助系统去查一下函数名，对一下参数等来确定即可。</p><h3 id="写注解"><a href="#写注解" class="headerlink" title="写注解"></a>写注解</h3><p>　　写注解是在阅读代码中最重要的一个步骤，在我们阅读的源代码一般来说是我们不熟悉的系统,阅读别人的代码一般会有几个问题：<br>1、搞明白别人的编程思想不 是一件很容易的事情，即使你知道这段程序的思路的时候也是一样。<br>2、阅读代码的时候代码量一般会比较大，如果不及时写注解往往会造成读明白了后边忘了前边的 现象。<br>3、阅读代码的时候难免会出现理解错误，如果没有及时的写注解很难及时的发现这些错误。<br>4、不写注解有时候你发现你很难确定一个函数你什么时候阅读过，它的功能是什么，经常会发生重复阅读、理解的现象。</p><p>好了，说一些写注解的基本方法：<br>1、猜测的去写，刚开始阅读一个代码的时候，你很难一下子就确定所有的函数的功能，不妨采用采用猜测的方法去写注解，根据函数的名字、位置写一个大致的注解，当然一般会有错误，但你的注解实际是不断调整的，直到最后你理解了全部代码。<br>2、按功能去写，别把注解写成语法说明书，千万别看到fopen就写打开文件，看到fread就写读数据，这样的注解一点用处都没有，而应该写“在此处开发参数配置文件(<em>**</em>.dat)”、“读出系统初始化参数……”这样才是有用的注解。<br>3、在写注解的使用另外要注意的一个问题是分清楚系统自动生成的代码和用户自己开发的代码，一般来说没有必要写系统自动生成的代码。象delphi的代码，我们往往要自己编写一些自己的代码段，还要对一些系统自动生成的代码段进行修改，这些代码在阅读过程是要写注解的，但有一些没有修改过的自动生成的代码就没有必要写注解了。<br>4、在主要代码段要写较为详细的注解。有一些函数或类在程序中起关键的作用，那么要写比较详细的注解。这样对你理解代码有很大的帮助。<br>5、对你理解起来比较困难的地方要写详细的注解，在这些地方往往会有一些编程的技巧。不理解这些编程技巧对你以后的理解或移植会有问题。<br>6、写中文注解。如果你的英文足够的好，不用看这条了，但很多的人英文实在不怎么样，那就写中文注解吧，我们写注解是为了加快自己的理解速度。中文在大多数的时候比英文更适应中国人。与其写一些谁也看不懂的英文注解还不如不写。</p><h3 id="重复阅读"><a href="#重复阅读" class="headerlink" title="重复阅读"></a>重复阅读</h3><p>　　一次就可以将所有的代码都阅读明白的人是没有的。至少我还没有遇到过。反复的去阅读同一段代码有助于对代码的理解。一般来说，在第一次阅读代码的时候 你可以跳过很多一时不明白的代码段，只写一些简单的注解，在以后的重复阅读过程中用，你对代码的理解会比上一次理解的更深刻，这样你可以修改那些注解错误的地方和上一次没有理解的地方。一般来说，对代码阅读3，4次基本可以理解代码的含义和作用。</p><h3 id="运行并修改代码"><a href="#运行并修改代码" class="headerlink" title="运行并修改代码"></a>运行并修改代码</h3><p>　　如果你的代码是可运行的，那么先让它运行起来，用单步跟踪的方法来阅读代码，会提高你的代码速度。代码通过看中间变量了解代码的含义,而且对以后的修改会提供很大的帮助。<br>　　用自己的代码代替原有代码，看效果，但在之前要保留源代码。<br>　　600行的一个函数，阅读起来很困难，编程的人不是一个好的习惯。在阅读这个代码的时候将代码进行修改，变成了14个函数。每一个大约是40-50行左右。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;收集所有可能收集的材料&quot;&gt;&lt;a href=&quot;#收集所有可能收集的材料&quot; class=&quot;headerlink&quot; title=&quot;收集所有可能收集的材料&quot;&gt;&lt;/a&gt;收集所有可能收集的材料&lt;/h3&gt;&lt;p&gt;阅读代码要做的第一件事情是收集所有和项目相关的资料。比如你要做一个项
      
    
    </summary>
    
      <category term="程序员生涯" scheme="https://deflin.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E6%B6%AF/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>基于CC3200实现WiFi Direct</title>
    <link href="https://deflin.github.io/2018/06/05/%E5%9F%BA%E4%BA%8ECC3200%E5%AE%9E%E7%8E%B0WiFi%20Direct/"/>
    <id>https://deflin.github.io/2018/06/05/基于CC3200实现WiFi Direct/</id>
    <published>2018-06-05T14:18:25.303Z</published>
    <updated>2018-06-06T11:57:37.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遇到的问题与解决"><a href="#遇到的问题与解决" class="headerlink" title="遇到的问题与解决"></a>遇到的问题与解决</h1><p>没接触过这类板子，有点陌生，不要紧，一步一步来。<br>问题一：<br>1.烧写了官方的SDK，按照提示，通过WiFi直连连接到了手机，但是失败概率很高，使用华为P10和魅蓝5连接不上，换用华为Nova2可以较为轻松的连上，暂时不知道是什么原因。<br>2.在网上下载了几个APP：serial WiFi，WiFi TCP/UDP，可以连接到cc3200，但是无法数据通信。想知道是否需要TI官方相关的配套APP才可以。          </p><p>解决一：<br>下载了个APP“magic iperf”,好像是有了点作用，串口打印出已经收到TCP数据，然而没有打印出接收到的数据啊。</p><p>问题二：<br>修改了程序，输出了接收缓冲区，但是输出的内容让人摸不着头脑。怎么看都不像是正常的数据包。现在最大的问题，应该怎样通过手机给模块发送TCP数据，并且通过串口打印输出到电脑上。代码里面找不到相关的内容，只有socket的创建，绑定端口等操作，在一个叫“BsdTcpServer”的函数里。这个函数，跟一般的建立一个TCP sever的基本思路大同小异，那么讲道理，TCP的接收数据的接口应该就是“sl_Recv”此类的函数，难道这个函数的参数“uBuf.BsdBuf”不是用于存放TCP数据包的吗？<br>现在大致的思路应该是，使用串口中断，将接收到的数据，通过TCP的这个接口函数，发送到移动终端，就好了吧。</p><p>解决二：<br>问题解决了，其实一直都是通的，但是这个官方的demo并没有将接收到的数据打印出来，仅仅是做了一个接收判断（即接收到数据后就亮一盏灯，然后打印出接收成功的字样）。另外，想要向手机端发送数据需要调用”sl_Send”函数，使用方式与“ sl_Recv ”类似。</p><p>问题三：<br>现在的现象有点奇怪，两个情况下WiFi模块会无法连接：<br>1.将开关拨到与WiFi模块相连，插上dongle，WiFi无法连接。另外，此时将开关拨到另一边，也不能连接WiFi。只有单独将WiFi模块复位才行。<br>2.在连接上之后，发送AT+NRB，会导致WiFi断开，并再无法连接。解决办法同上，也是要将WiFi模块复位才行。<br>根据以上现象来看，似乎是WiFi跟NB模组连接的串口导致。但是什么样的串口问题会导致这种情况呢？</p><p>解决三：<br>以上出现的现象原来是因为跟WiFi相连的另一路串口没有配置导致的，与NB模块LOGVIEW口相连的UART0串口，会在NB模块启动的时候收到log数据，导致WiFi模块卡死。为什么会卡死，我还不太明白，为什么没有配置的串口收到数据会导致程序卡死。</p><p>导致模块复位的原因知道了，是程序里的一个复位Pin脚占用了UART0的串口。</p><p>问题四：<br>虽然配置好了两路的串口，但是发现，在收发AT命令的时候，两路串口好像会有干扰，导致收到的数据是乱码。之所以会这么觉得，是以为屏蔽了另一路串口问题就解决了。UART0的配置如下：<br>1.引脚配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void PinMuxConfig(void)</span><br><span class="line">&#123;</span><br><span class="line">    // Enable Peripheral Clocks</span><br><span class="line">    MAP_PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK);</span><br><span class="line"></span><br><span class="line">    MAP_PinTypeUART(PIN_03, PIN_MODE_7);//UART0</span><br><span class="line"></span><br><span class="line">    MAP_PinTypeUART(PIN_04, PIN_MODE_7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.串口属性配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void LOGVIEWComPort_Init_921600(void)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">   MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8);</span><br><span class="line">   MAP_UARTFIFOEnable(COM_P0);</span><br><span class="line">   MAP_UARTFlowControlSet(COM_P0, UART_FLOWCONTROL_NONE);</span><br><span class="line">  </span><br><span class="line">   MAP_UARTConfigSetExpClk(COM_P0,MAP_PRCMPeripheralClockGet(COM_P0_PERIPH),</span><br><span class="line">                            921600, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |</span><br><span class="line">                                             UART_CONFIG_PAR_NONE));</span><br><span class="line">   MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler);</span><br><span class="line">   MAP_IntPrioritySet(INT_UARTA0,INT_PRIORITY_LVL_0);</span><br><span class="line">   MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待解决四：<br>进一步尝试，发现是这几句话会导致串口干扰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8);</span><br><span class="line">    MAP_UARTFIFOEnable(COM_P0);</span><br><span class="line">    MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler);</span><br><span class="line">    MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">解决四：</span><br><span class="line"></span><br><span class="line">问题原因是没有处理中断接收的数据，导致的干扰，配置好中断的处理函数之后就没有这样的问题了，不是以上这几条语句导致的。</span><br><span class="line"></span><br><span class="line">问题五：</span><br><span class="line">socket的数据流程整理了一下，数据结构挺庞大，好在还算清晰。简单的流程如下图：</span><br><span class="line"></span><br><span class="line">![] (https://app.yinxiang.com/shard/s62/res/14408816-1d63-434e-9576-39a18458d2c2)</span><br><span class="line"></span><br><span class="line">然后，数据是怎样从串口传到socket的呢？貌似是通过全局的队列，就是下面的这个函数，在UART的接收中断中执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line"></span><br><span class="line">void uart_get_char(char c)</span><br><span class="line">&#123;</span><br><span class="line">    char flag = 0;</span><br><span class="line">    portBASE_TYPE xHigherPriorityTaskWoken;</span><br><span class="line">    uart_timer_stop();</span><br><span class="line">    lps_event_timer = 0;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len_queue(&amp;g_p_uart_buf-&gt;queue) == UART_FRAME_MAX_LEN - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">    &#125;</span><br><span class="line">//队列满的情况计数，这部分代码可以复用</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (full_quene(&amp;g_p_uart_buf-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        uart_bug_count++;   //计数用来测试串口数据满的情况</span><br><span class="line">        Report(<span class="string">"full_quene\r\n"</span>);</span><br><span class="line">        LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"full_quene\r\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;lostNew) //丢弃最新的数据</span><br><span class="line">        &#123;</span><br><span class="line">            g_uart_to_sock_cnt++;       </span><br><span class="line">            portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            g_p_uart_buf-&gt;queue.rear = (g_p_uart_buf-&gt;queue.rear + 1) % QUEUE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (g_p_uart_buf-&gt;tmodeState == TMODE_CMD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)  //有些命令以\r\n结束</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里把串口收的数据放到这里</span><br><span class="line">    en_queue(&amp;g_p_uart_buf-&gt;queue, c);</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        g_uart_to_sock_cnt++;</span><br><span class="line">        portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;tmodeState == TMODE_CMD)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_p_uart_buf-&gt;<span class="built_in">echo</span> == ECHO_ON)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">'\r'</span> != c)</span><br><span class="line">                &#123;</span><br><span class="line">                    uart_output_byte(COM_P1, c);</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\b'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                de_queue_font(&amp;g_p_uart_buf-&gt;queue);    // delete <span class="string">'\b'</span></span><br><span class="line">                de_queue_font(&amp;g_p_uart_buf-&gt;queue);    // delete <span class="string">'previous'</span></span><br><span class="line">                uart_output_byte(COM_P1, <span class="string">' '</span>);</span><br><span class="line">                uart_output_byte(COM_P1, <span class="string">'\b'</span>);</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\r'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                g_uart_to_at_cnt++;</span><br><span class="line">                portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            uart_timer_start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上存储数据的操作之后，将队列中的数据存到socket的数组中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">void uart_recv_task(void *argc)</span><br><span class="line">&#123;</span><br><span class="line">    uartParaStruct *pUartPara = (uartParaStruct *)argc;</span><br><span class="line">    threadParaStruct *pThreadPara = pUartPara-&gt;para;</span><br><span class="line">    uartBuf_typeDef *pBuf = l_v_uart_buf;</span><br><span class="line">    char *pBufAt = NULL;</span><br><span class="line">  </span><br><span class="line">    unsigned short pos;</span><br><span class="line">    int i;</span><br><span class="line">    char existSock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pThreadPara-&gt;threadCompleted)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((l_uart_to_sock_cnt &gt; 0))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l_uart_to_sock_cnt &gt; 3)</span><br><span class="line">            &#123;</span><br><span class="line">                l_uart_to_sock_cnt = 3;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pBuf-&gt;queue.font;</span><br><span class="line"></span><br><span class="line">            // 从串口buffer中取出数据</span><br><span class="line">            // 若无网络task，可以使用串口接受callback</span><br><span class="line">            // 故每次直接从队列中取出数据，且tempbuf清楚</span><br><span class="line">            pBuf-&gt;tempBufLen = 0;</span><br><span class="line">            memset(pBuf-&gt;tempBuf, 0, sizeof(pBuf-&gt;tempBuf));</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (empty_quene(&amp;pBuf-&gt;queue))</span><br><span class="line">                &#123;</span><br><span class="line">                    l_uart_to_sock_cnt = 0;</span><br><span class="line">         </span><br><span class="line">                    uart_debug(<span class="string">"The uart queue is empty,need check code\n"</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt;= UART_FRAME_MAX_LEN)</span><br><span class="line">                &#123;</span><br><span class="line">          </span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                de_queue(&amp;pBuf-&gt;queue, &amp;pBuf-&gt;tempBuf[pBuf-&gt;tempBufLen]);</span><br><span class="line">                pBuf-&gt;tempBufLen++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">while</span> (pos != pBuf-&gt;queue.rear);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //uart callback</span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;recv_callback)</span><br><span class="line">                &#123;</span><br><span class="line">                    pBuf-&gt;tempBufLen = pBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_REDAY, (void *)pBuf, pBuf-&gt;tempBuf, pBuf-&gt;tempBufLen);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //still have data,send quene to net task</span><br><span class="line">                <span class="keyword">if</span> (pBuf-&gt;tempBufLen &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    existSock = 0;</span><br><span class="line">                    <span class="keyword">if</span> (g_sock_used[1] == TRUE) //当前sock建立</span><br><span class="line">                    &#123;</span><br><span class="line">    </span><br><span class="line">                      pBuf-&gt;sockSendLen[1] = pBuf-&gt;tempBufLen;</span><br><span class="line">                      existSock = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (existSock)</span><br><span class="line">                    &#123;</span><br><span class="line">                        msleep(_DELAY_SWITCH_CONTEXT_MS); // 任务挂起，让给高优先级的sock</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        existSock = 0;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> ((g_sock_used[1] == TRUE) &amp;&amp; (g_sock_tcp[1] == TRUE))</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="keyword">if</span> (pBuf-&gt;sockSendLen[1] &gt; 0) //  1</span><br><span class="line">                          &#123;</span><br><span class="line">                            existSock = 1;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (existSock)</span><br><span class="line">                        &#123;</span><br><span class="line">                            msleep(_DELAY_FOR_WAIT_SOCK);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l_uart_to_sock_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l_uart_to_sock_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            msleep(30);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，在socket的任务中会检测是否有数据存在，有的话就通过接口函数发送到网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">//如果接收到了数据</span><br><span class="line">      <span class="keyword">if</span> (g_p_uart_buf != NULL)</span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT)</span><br><span class="line">        &#123;</span><br><span class="line">          int send_len = g_p_uart_buf-&gt;sockSendLen[id];</span><br><span class="line">          //socka_debug(<span class="string">"uart recv data\r\n"</span>);</span><br><span class="line">          //socka_debug(<span class="string">"id=%d\r\n"</span>, id);</span><br><span class="line">          start_time = xTaskGetTickCount();   // 获取ejoin 开始时间</span><br><span class="line">          //<span class="keyword">if</span>(strlen(g_p_uart_buf-&gt;tempBuf))</span><br><span class="line">          </span><br><span class="line">          ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0);</span><br><span class="line">          first_time = xTaskGetTickCount();</span><br><span class="line">          LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"(%d,%u)\r\n"</span>, first_time-start_time, start_time);</span><br><span class="line">          <span class="keyword">if</span> ((ret &lt; 0)  || (ret == 0))</span><br><span class="line">          &#123;</span><br><span class="line">            socka_debug(<span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            sock_fd = -1;</span><br><span class="line">            </span><br><span class="line">            pThreadPara-&gt;threadCompleted = TRUE;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (send_len != ret)      //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了</span><br><span class="line">          &#123;</span><br><span class="line">            //网络未正常断开的时候，不能用send检测到</span><br><span class="line">            //这里发送失败就选择重新发送，接收的select中会检测到断网</span><br><span class="line">            //socka_debug(<span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (reSendTimers++ &gt; NET_RECONNECT_TIMES)   // 丢弃数据</span><br><span class="line">            &#123;</span><br><span class="line">              //reSendTimers = reSendTimers;</span><br><span class="line">              g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              msleep(20);</span><br><span class="line">              <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          needSleep = 0;</span><br><span class="line">          reSendTimers = 0;</span><br><span class="line">          g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(NULL != pNetBuf-&gt;recv_callback)  // 150423</span><br><span class="line">          &#123;</span><br><span class="line">            pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          //          socka_debug(<span class="string">"uart not recvd, wait...\r\n"</span>);</span><br><span class="line">          osi_Sleep(10);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">//如果接收到了数据</span><br><span class="line">      <span class="keyword">if</span> (g_p_uart_buf != NULL)</span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="keyword">if</span> (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT)</span><br><span class="line">        &#123;</span><br><span class="line">          int send_len = g_p_uart_buf-&gt;sockSendLen[id];</span><br><span class="line">          //socka_debug(<span class="string">"uart recv data\r\n"</span>);</span><br><span class="line">          //socka_debug(<span class="string">"id=%d\r\n"</span>, id);</span><br><span class="line">          start_time = xTaskGetTickCount();   // 获取ejoin 开始时间</span><br><span class="line">          //<span class="keyword">if</span>(strlen(g_p_uart_buf-&gt;tempBuf))</span><br><span class="line">          </span><br><span class="line">          ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0);</span><br><span class="line">          first_time = xTaskGetTickCount();</span><br><span class="line">          LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"(%d,%u)\r\n"</span>, first_time-start_time, start_time);</span><br><span class="line">          <span class="keyword">if</span> ((ret &lt; 0)  || (ret == 0))</span><br><span class="line">          &#123;</span><br><span class="line">            socka_debug(<span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"socka send error\r\n"</span>);</span><br><span class="line">            close(sock_fd);</span><br><span class="line">            sock_fd = -1;</span><br><span class="line">            </span><br><span class="line">            pThreadPara-&gt;threadCompleted = TRUE;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (send_len != ret)      //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了</span><br><span class="line">          &#123;</span><br><span class="line">            //网络未正常断开的时候，不能用send检测到</span><br><span class="line">            //这里发送失败就选择重新发送，接收的select中会检测到断网</span><br><span class="line">            //socka_debug(<span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            LSD_Debug(LSD_DEBUG_LEVEL_3, <span class="string">"sock(%d) send fail\r\n"</span>, id);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (reSendTimers++ &gt; NET_RECONNECT_TIMES)   // 丢弃数据</span><br><span class="line">            &#123;</span><br><span class="line">              //reSendTimers = reSendTimers;</span><br><span class="line">              g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              msleep(20);</span><br><span class="line">              <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          needSleep = 0;</span><br><span class="line">          reSendTimers = 0;</span><br><span class="line">          g_p_uart_buf-&gt;sockSendLen[id] = 0;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(NULL != pNetBuf-&gt;recv_callback)  // 150423</span><br><span class="line">          &#123;</span><br><span class="line">            pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          //          socka_debug(<span class="string">"uart not recvd, wait...\r\n"</span>);</span><br><span class="line">          osi_Sleep(10);</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>现在遇到的麻烦是，开启sockB的时候，会导致堆栈溢出。</p><p>很好，堆栈溢出的问题解决了，原因是任务分配的内存大小不够，sockB的任务。</p><p>然而，新的问题又出现了，使用sockB无法连接。</p><p>最新问题，当数据大于等于512个字节时，队列的缓冲区就满了，很奇怪，明明分配了0x1600的空间，却用不到那么空间。</p><p>解决五：</p><p>上述问题都解决了，但实际上还遗留着一个问题，就是使用socketB作为lowview的数据通道时，串口中断的队列会溢出。现在的做法是，将socketB换成了AT命令的数据通道。问题得以规避。原因却没有找到，大概是socketB发送数据时出队的设计这边有些问题，支撑不了这么快的数据。</p><p>问题六：</p><p>AT串口出现断包的现象，想想是什么原因吧，可是NB模块又是返回正确的数据长度以及OK，然而服务器那边却收不到断了的数据包。这是为什么？<br>明天早上先把串口换一下试试。</p><p>解决六：</p><p>接收断包的现象可能跟WiFi模块的信号有关，使用手机做热点的时候并不会有这种现象，并且，这现象只发生在模块刚启动的一会儿，过一会就不再有这种情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;遇到的问题与解决&quot;&gt;&lt;a href=&quot;#遇到的问题与解决&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题与解决&quot;&gt;&lt;/a&gt;遇到的问题与解决&lt;/h1&gt;&lt;p&gt;没接触过这类板子，有点陌生，不要紧，一步一步来。&lt;br&gt;问题一：&lt;br&gt;1.烧写了官方的SD
      
    
    </summary>
    
      <category term="CC32xx系列开发" scheme="https://deflin.github.io/categories/CC32xx%E7%B3%BB%E5%88%97%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CC3200" scheme="https://deflin.github.io/tags/CC3200/"/>
    
      <category term="单片机" scheme="https://deflin.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="WiFi" scheme="https://deflin.github.io/tags/WiFi/"/>
    
  </entry>
  
  <entry>
    <title>va_start和va_end使用详解</title>
    <link href="https://deflin.github.io/2018/06/01/va_start%E5%92%8Cva_end%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://deflin.github.io/2018/06/01/va_start和va_end使用详解/</id>
    <published>2018-06-01T03:21:52.155Z</published>
    <updated>2018-06-05T11:53:49.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表</p><p>void foo(…);<br>void foo(parm_list,…);<br>这种方式和我们以前认识的不大一样，但我们要记住这是C中一种传参的形式，在后面我们就会用到它。</p><p>2.函数参数的传递原理<br>　　函数参数是以数据结构:栈的形式存取,从右至左入栈。</p><p>　　首先是参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址，举个例子如下：<br>void func(int x, float y, char z);<br>　　那么，调用函数的时候，实参 char z 先进栈，然后是 float y，最后是 int x，因此在内存中变量的存放次序是 x-&gt;y-&gt;z，因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过指针移位运算，则总可以顺藤摸瓜找到其他的输入变量。</p><p>　　下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：<br>typedef char<em> va_list;<br>void va_start ( va_list ap, prev_param ); /</em> ANSI version */<br>type va_arg ( va_list ap, type );<br>void va_end ( va_list ap );<br>va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。</p><p><step 1=""> 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</step></p><p><step 2=""> 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数；</step></p><p><step 3=""> 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；</step></p><p><step 4=""> 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。</step></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream.h&gt; void fun(int a, ...) &#123; 　　int *temp = &amp;a;　　temp++;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">for</span> (int i = 0; i &lt; a; ++i) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　cout &lt;&lt; *temp &lt;&lt; endl; </span><br><span class="line">　　　　temp++; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">　　int a = 1; </span><br><span class="line">　　int b = 2; </span><br><span class="line">　　int c = 3; </span><br><span class="line">　　int d = 4; </span><br><span class="line">　　fun(4, a, b, c, d); </span><br><span class="line">　　system(<span class="string">"pause"</span>); </span><br><span class="line">　　<span class="built_in">return</span> 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Output:: </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>3:获取省略号指定的参数<br>　　在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。像这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void TestFun(char* pszDest, int DestLen, const char* pszFormat, ...) &#123; va_list args; va_start(args, pszFormat); //一定要“...”之前的那个参数_vsnprintf(pszDest, DestLen, pszFormat, args); va_end(args); &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4.演示如何使用参数个数可变的函数，采用ANSI标准形式 </span><br><span class="line"><span class="comment">#include 〈stdio.h〉 </span></span><br><span class="line"><span class="comment">#include 〈string.h〉 </span></span><br><span class="line"><span class="comment">#include 〈stdarg.h〉 </span></span><br><span class="line"></span><br><span class="line">/*函数原型声明，至少需要一个确定的参数，注意括号内的省略号*/ </span><br><span class="line">int demo( char, ... ); </span><br><span class="line">void main( void ) </span><br><span class="line">&#123; </span><br><span class="line">   demo(<span class="string">"DEMO"</span>, <span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"demo!"</span>, <span class="string">""</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*ANSI标准形式的声明方式，括号内的省略号表示可选参数*/ </span><br><span class="line">int demo( char msg, ... ) </span><br><span class="line">&#123; </span><br><span class="line">       /*定义保存函数参数的结构*/</span><br><span class="line">   va_list argp; </span><br><span class="line">   int argno = 0; </span><br><span class="line">   char para; </span><br><span class="line">　　   /*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/ </span><br><span class="line">   va_start( argp, msg ); </span><br><span class="line">   <span class="keyword">while</span> (1) </span><br><span class="line">       &#123; </span><br><span class="line">        para = va_arg( argp, char); </span><br><span class="line">           <span class="keyword">if</span> ( strcmp( para, <span class="string">""</span>) == 0 ) </span><br><span class="line">               <span class="built_in">break</span>; </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"Parameter #%d is: %s\n"</span>, argno, para); </span><br><span class="line">           argno++; </span><br><span class="line">&#125; </span><br><span class="line">va_end( argp ); </span><br><span class="line">/*将argp置为NULL*/</span><br><span class="line"><span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表&lt;/p&gt;
&lt;p&gt;void foo(…);&lt;br&gt;void 
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>可变参数函数用法</title>
    <link href="https://deflin.github.io/2018/05/30/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <id>https://deflin.github.io/2018/05/30/可变参数函数用法/</id>
    <published>2018-05-30T13:26:12.694Z</published>
    <updated>2018-06-05T11:54:13.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>typedef char* va_list;//用于声明一个指向参数列表的字符型指针变量<br>void va_start(va_list ap,prev_param);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的第一个参数，通常用于指定可变参数列表中参数的个数<br>void va_arg(va_list ap,type);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的数据类型<br>void va_end(va_list ap);//将存放可变参数字符串的变量清空（赋值为NULL）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int sum(int count,...)//计算和</span><br><span class="line">&#123;</span><br><span class="line">     int sum = 0;</span><br><span class="line">     int i;</span><br><span class="line">     va_list ap;</span><br><span class="line">     va_start(ap,count);</span><br><span class="line">     <span class="keyword">for</span>(i=0;i&lt;count;++i)</span><br><span class="line">     &#123;</span><br><span class="line">          sum+=va_arg(ap,int);</span><br><span class="line">     &#125;</span><br><span class="line">     va_end(ap);</span><br><span class="line">     <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>,sum(3,1,2,3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;example&quot;&gt;&lt;a href=&quot;#example&quot; class=&quot;headerlink&quot; title=&quot;example&quot;&gt;&lt;/a&gt;example&lt;/h2&gt;&lt;p&gt;typedef char* va_list;//用于声明一个指向参数列表的字符型指针变量&lt;br&gt;vo
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>关于回调函数的理解</title>
    <link href="https://deflin.github.io/2018/05/26/%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://deflin.github.io/2018/05/26/关于回调函数的理解/</id>
    <published>2018-05-26T14:07:01.285Z</published>
    <updated>2018-06-05T11:54:02.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p><p>实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。</p><p>populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdlib.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line">// 回调函数 </span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span> (size_t i=0; i&lt;arraySize; i++) </span><br><span class="line">        array[i] = getNextValue(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 获取随机值 </span><br><span class="line">int getNextRandomValue(void) &#123; </span><br><span class="line"></span><br><span class="line">     <span class="built_in">return</span> rand(); </span><br><span class="line">&#125; </span><br><span class="line">int main(void) </span><br><span class="line">&#123; </span><br><span class="line">    int myarray[10];</span><br><span class="line"></span><br><span class="line">//此处getNextValue指向 getNextRandomValue函数的地址，起到调用作用</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, myarray[i]); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">    <span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;example&quot;&gt;&lt;a href=&quot;#example&quot; class=&quot;headerlink&quot; title=&quot;example&quot;&gt;&lt;/a&gt;example&lt;/h2&gt;&lt;p&gt;实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设
      
    
    </summary>
    
      <category term="当时我所不知道的C语言" scheme="https://deflin.github.io/categories/%E5%BD%93%E6%97%B6%E6%88%91%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://deflin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
