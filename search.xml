<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CoAP协议——格式详解]]></title>
    <url>%2F2018%2F06%2F10%2FCoAP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CoAP格式详解CoAP是受限制的应用协议(Constrained Application Protocol)的代名词。在当前由PC机组成的世界，交换是通过TCP和应用层协议HTTP实现的。但是对于小型设备而言，实现TCP和HTTP协议显然是一个过分的要求。为了让小设备可以接入，CoAP协议被设计出来。CoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。CoAP协议非常小巧，最小的包仅为4字节。 1.CoAP协议综述和其他TCP IP协议簇中的协议一样，CoAP协议总是以“头”的形式出现在负载之前，而负载和CoAP头之间使用单字节0xFF分离。学习CoAP协议最好的方法便是结合RFC文档，详细分析CoAP协议报文格式的每一部分，便是CoAP协议报文结构示意图。 2.CoAP协议报文结构示意图【Ver】 版本编号，指示CoAP协议的版本号。类似于HTTP 1.0 HTTP 1.1。版本编号占2位，取值为01B。 【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。 【TKL】CoAP标识符长度。CoAP协议中具有两种功能相似的标识符，一种为Message ID(报文编号)，一种为Token(标识符)。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。 【Code】功能码/响应码。Code在CoAP请求报文和响应报文中具有不同的表现形式，Code占一个字节，它被分成了两部分，前3位一部分，后5位一部分，为了方便描述它被写成了c.dd结构。其中0.XX表示CoAP请求的某种方法，而2.XX、4.XX或5.XX则表示CoAP响应的某种具体表现。 【Message ID】报文编号 【Token】标识符具体内容，通过TKL指定Token长度。 【Option】报文选项，通过报文选项可设定CoAP主机，CoAP URI，CoAP请求参数和负载媒体类型等等。 【1111 1111B】CoAP报文和具体负载之间的分隔符。 3.Code部分详解 Code部分被分成了两部分，为了便于阅读，Code被描述为c.dd形式。具体内容可参考RFC7252 #12.1.1 Method Codes 3.1 请求在CoAP请求中，Code被定义为CoAP请求方法，这些方法有GET、POST、PUT和DELETE，这些方法和HTTP协议非常相似。 【0.01】GET方法——用于获得某资源 【0.02】POST方法——用于创建某资源 【0.03】PUT方法——用于更新某资源 【0.04】DELETE方法——用于删除某资源 3.2 响应在CoAP响应中，Code被定义为CoAP响应码，类似于HTTP 200 OK等等。 【2.01】Created 【2.02】Deleted 【2.03】Valid 【2.04】Changed 【2.05】Content。类似于HTTP 200 OK 【4.00】Bad Request 请求错误，服务器无法处理。类似于HTTP 400。 【4.01】Unauthorized 没有范围权限。类似于HTTP 401。 【4.02】Bad Option 请求中包含错误选项。 【4.03】Forbidden 服务器拒绝请求。类似于HTTP 403。 【4.04】Not Found 服务器找不到资源。类似于HTTP 404。 【4.05】Method Not Allowed 非法请求方法。类似于HTTP 405。 【4.06】Not Acceptable 请求选项和服务器生成内容选项不一致。类似于HTTP 406。 【4.12】Precondition Failed 请求参数不足。类似于HTTP 412。 【4.15】Unsuppor Conten-Type 请求中的媒体类型不被支持。类似于HTTP 415。 【5.00】Internal Server Error 服务器内部错误。类似于HTTP 500。 【5.01】Not Implemented 服务器无法支持请求内容。类似于HTTP 501。 【5.02】Bad Gateway 服务器作为网关时，收到了一个错误的响应。类似于HTTP 502。 【5.03】Service Unavailable 服务器过载或者维护停机。类似于HTTP 503。 【5.04】Gateway Timeout 服务器作为网关时，执行请求时发生超时错误。类似于HTTP 504。 【5.05】Proxying Not Supported 服务器不支持代理功能。 4.Option部分详解CoAP支持多个Option，CoAP的Option的表示方法比较特殊，采用增量的方式描述，细节可参考RFC7252 #3.1 CoAP支持多个Option，CoAP的Option的表示方法比较特殊，采用增量的方式描述，细节可参考RFC7252 #3.1 一般情况下Option部分包含Option Delta、Option Length和Option Value三部分。 【Option Delta】表示Option的增量，当前的Option的具体编号等于之前所有Option Delta的总和。 【Option Length】表示Option Value的具体长度。 【Option Value】表示Option具体内容 CoAP中所有的Option都采用编号的方式，这些Option及编号的定义如下图所示。 在这些option中，Uri-Host、Uri-Port、Uri-Path和Uri-Query等和资源“位置”和参数有关。 【3】Uri-Host:CoAP主机名称，例如iot.eclipse.org 【7】Uri-Port:CoAP端口号，默认为5683 【11】Uri-Path:资源路由或路径，例如\temperature。资源路径采用UTF8字符串形式，长度不计第一个”\”。 【15】Uri-Query:访问资源参数，例如?value1=1&amp;value2=2，参数与参数之间使用“&amp;”分隔，Uri-Query和Uri-Path之间采用“?”分隔。 在这些option中，Content-Format和Accept用于表示CoAP负载的媒体格式 【12】Content-Format:指定CoAP复杂媒体类型，媒体类型采用整数描述，例如application/json对应整数50，application/octet-stream对应整数40。 【17】Accept: 指定CoAP响应复杂中的媒体类型，媒体类型的定义和Content-Format相同。 CoAP协议中支持多个Option，例如 第一个Option Delta=11，表示该Option表示Uri-Path(11) 第二个Option Delta=1，表示该Option=1+11，表示Content-Format(12) 第三个Option Delta=3，表示该Option=3+1+11，表示Uri-Query(15) CoAP采用这样的方式表示多个Option，而每种Option都可以在HTTP协议中找到对应项。 5.Content-Format描述CoAP支持多种媒体类型，具体可参考RFC7252 #12.3。从下图的信息可以发现，CoAP协议中关于媒体类型的定义比较简单，未来应该会根据实际情况扩展。 【text/plain】 编号为0，表示负载为字符串形式，默认为UTF8编码。 【application/link-format】编号为40，CoAP资源发现协议中追加定义，该媒体类型为CoAP协议特有。 【application/xml】编号为41，表示负载类型为XML格式。 【application/octet-stream】编号为42，表示负载类型为二进制格式。 【application/exi】编号为47，表示负载类型为“精简XML”格式。(翻译不一定准确) 另外，还有一种格式也北IANA认定，也会在CoAP协议中广泛使用那便是CBOR格式，该格式可理解为二进制JSON格式。 【applicaiton/cbor】编号为60。 6.示例该示例来自于RFC7252。 【流程描述】 CoAP客户端通过GET方法从Server端获得温度传感器数据，CoAP URI如下 coap://www.server.com/temperautre CoAP请求采用CON报文，Server接收到CON报文必须返回一个ACK报文。CoAP请求采用0.01 GET方法，若操作成功CoAP Server返回2.05 Content，相当于HTTP 200 OK。请求和响应的MID必须完全相同，此处为0x7d34。请求响应中的Token域为空。CoAP请求中包含Option，该Option的类型为Uri-Path，那么Option Delta的值为0+11=11，Option Value的值为字符串形式的“temperature”。CoAP返回中包含温度数据，使用字符串形式描述，具体值为”22.3”。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>CoAP</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读代码]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[收集所有可能收集的材料阅读代码要做的第一件事情是收集所有和项目相关的资料。比如你要做一个项目的售后服务，那么你首先要搞明白项目做什么用的，那么调研文档、概要设计文档、详细设计文档、测试文档、使用手册都是你要最先搞到手的。如果你是为了学习那么尽量收集和你的学习有关的资料，比如你想学习Linux的文件系统的代码，那最好要找到linux的使用手册、以及文件系统设计的方法、数据结构的说明。(这些资料在书店里都可以找到)。 材料的种类分为几种类型1.基础资料。比如你阅读turbo c2的源代码你要有turbo c2的函数手册，使用手册等专业书籍，msc 6.0或者Java 的话不但要有函数手册，还要有类库函数手册。这些资料都是你的基础资料。另外你要有一些关于uml的资料可以作为查询手册也是一个不错的选择。 2.和程序相关的专业资料。 每一个程序都是和相关行业相关的。比如我阅读过一个关于气象分析方面的代码，因为里边用到了一个复杂的数据转换公式，所以不得不把自己的大学时候课本 找出来来复习一下高等数学的内容。如果你想阅读linux的文件管理的代码，那么找一本讲解linux文件系统的书对你的帮助会很大。 3.相关项目的文档资料 这一部分的资料分为两种，一个相关行业的资料，比如你要阅读一个税务系统的代码那么有一些财务/税务系统的专业资料和国家的相关的法律、法规的资料是 必不可少的。此外就是关于这个项目的需求分析报告、概要设计报告、详细设计报告，使用手册、测试报告等，尽量多收集对你以后的代码阅读是很重要的 知识准备 了解基础知识，不要上来就阅读代码，打好基础可以做到事半功倍的效果 留备份,构造可运行的环境 代码拿到手之后的第一件事情是先做备份，最好是刻在一个光盘上，在代码阅读的时候一点不动代码是很困难的一件事情，特别是你要做一些修改性或增强性维护的时候。而一旦做修改就可能发生问题，到时候要恢复是经常发生的事情，如果你不能很好的使用版本控制软件那么先留一个备份是一个最起码的要求了。 在做完备份之后最好给自己构造一个可运行的环境，当然可能会很麻烦，但可运行代码和不可运行的代码阅读起来难度会差很多的。所以多用一点时间搭建一个环境是很值得的，而且我们阅读代码主要是为了修改其中的问题或做移植操作。不能运行的代码除了可以学到一些技术以外，用处有限。 找开始的地方 做什么事情都要知道从那里开始，读程序也不例外。在C语言里,首先要找到main()函数，然后逐层去阅读，其他的程序无论是vb、delphi都要首先找到程序头，否则你是很难分析清楚程序的层次关系。 分层次阅读 在阅读代码的时候不要一头就扎下去，这样往往容易只见树木不见森林，阅读代码比较好的方法有一点象二叉树的广度优先的遍历。在程序主体一般会比较简 单，调用的函数会比较少，根据函数的名字以及层次关系一般可以确定每一个函数的大致用途，将你的理解作为注解写在这些函数的边上。当然很难一次就将全部注 解都写正确，有时候甚至可能是你猜测的结果，不过没有关系这些注解在阅读过程是不断修正的，直到你全部理解了代码为止。一般来说采用逐层阅读的方法可以是 你系统的理解保持在一个正确的方向上。避免一下子扎入到细节的问题上。在分层次阅读的时候要注意一个问题，就是将系统的函数和开发人员编写代码区分开。在 c, c++，java ,delphi中都有自己的系统函数，不要去阅读这些系统函数，除非你要学习他们的编程方法，否则只会浪费你的时间。将系统函数表示出来，注明它们的作用 即可，区分系统函数和自编函数有几个方法，一个是系统函数的编程风格一般会比较好，而自编的函数的编程风格一般比较会比较差。从变量名、行之间的缩进、注 解等方面一般可以分辨出来，另外一个是像ms c6++会在你编程的时候给你生成一大堆文件出来，其中有很多文件是你用不到了，可以根据文件名来区分一下时候是系统函数，最后如果你实在确定不了，那就 用开发系统的帮助系统去查一下函数名，对一下参数等来确定即可。 写注解 写注解是在阅读代码中最重要的一个步骤，在我们阅读的源代码一般来说是我们不熟悉的系统,阅读别人的代码一般会有几个问题：1、搞明白别人的编程思想不 是一件很容易的事情，即使你知道这段程序的思路的时候也是一样。2、阅读代码的时候代码量一般会比较大，如果不及时写注解往往会造成读明白了后边忘了前边的 现象。3、阅读代码的时候难免会出现理解错误，如果没有及时的写注解很难及时的发现这些错误。4、不写注解有时候你发现你很难确定一个函数你什么时候阅读过，它的功能是什么，经常会发生重复阅读、理解的现象。 好了，说一些写注解的基本方法：1、猜测的去写，刚开始阅读一个代码的时候，你很难一下子就确定所有的函数的功能，不妨采用采用猜测的方法去写注解，根据函数的名字、位置写一个大致的注解，当然一般会有错误，但你的注解实际是不断调整的，直到最后你理解了全部代码。2、按功能去写，别把注解写成语法说明书，千万别看到fopen就写打开文件，看到fread就写读数据，这样的注解一点用处都没有，而应该写“在此处开发参数配置文件(**.dat)”、“读出系统初始化参数……”这样才是有用的注解。3、在写注解的使用另外要注意的一个问题是分清楚系统自动生成的代码和用户自己开发的代码，一般来说没有必要写系统自动生成的代码。象delphi的代码，我们往往要自己编写一些自己的代码段，还要对一些系统自动生成的代码段进行修改，这些代码在阅读过程是要写注解的，但有一些没有修改过的自动生成的代码就没有必要写注解了。4、在主要代码段要写较为详细的注解。有一些函数或类在程序中起关键的作用，那么要写比较详细的注解。这样对你理解代码有很大的帮助。5、对你理解起来比较困难的地方要写详细的注解，在这些地方往往会有一些编程的技巧。不理解这些编程技巧对你以后的理解或移植会有问题。6、写中文注解。如果你的英文足够的好，不用看这条了，但很多的人英文实在不怎么样，那就写中文注解吧，我们写注解是为了加快自己的理解速度。中文在大多数的时候比英文更适应中国人。与其写一些谁也看不懂的英文注解还不如不写。 重复阅读 一次就可以将所有的代码都阅读明白的人是没有的。至少我还没有遇到过。反复的去阅读同一段代码有助于对代码的理解。一般来说，在第一次阅读代码的时候 你可以跳过很多一时不明白的代码段，只写一些简单的注解，在以后的重复阅读过程中用，你对代码的理解会比上一次理解的更深刻，这样你可以修改那些注解错误的地方和上一次没有理解的地方。一般来说，对代码阅读3，4次基本可以理解代码的含义和作用。 运行并修改代码 如果你的代码是可运行的，那么先让它运行起来，用单步跟踪的方法来阅读代码，会提高你的代码速度。代码通过看中间变量了解代码的含义,而且对以后的修改会提供很大的帮助。 用自己的代码代替原有代码，看效果，但在之前要保留源代码。 600行的一个函数，阅读起来很困难，编程的人不是一个好的习惯。在阅读这个代码的时候将代码进行修改，变成了14个函数。每一个大约是40-50行左右。]]></content>
      <categories>
        <category>程序员生涯</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于CC3200实现WiFi Direct]]></title>
    <url>%2F2018%2F06%2F05%2F%E5%9F%BA%E4%BA%8ECC3200%E5%AE%9E%E7%8E%B0WiFi%20Direct%2F</url>
    <content type="text"><![CDATA[遇到的问题与解决没接触过这类板子，有点陌生，不要紧，一步一步来。问题一：1.烧写了官方的SDK，按照提示，通过WiFi直连连接到了手机，但是失败概率很高，使用华为P10和魅蓝5连接不上，换用华为Nova2可以较为轻松的连上，暂时不知道是什么原因。2.在网上下载了几个APP：serial WiFi，WiFi TCP/UDP，可以连接到cc3200，但是无法数据通信。想知道是否需要TI官方相关的配套APP才可以。 解决一：下载了个APP“magic iperf”,好像是有了点作用，串口打印出已经收到TCP数据，然而没有打印出接收到的数据啊。 问题二：修改了程序，输出了接收缓冲区，但是输出的内容让人摸不着头脑。怎么看都不像是正常的数据包。现在最大的问题，应该怎样通过手机给模块发送TCP数据，并且通过串口打印输出到电脑上。代码里面找不到相关的内容，只有socket的创建，绑定端口等操作，在一个叫“BsdTcpServer”的函数里。这个函数，跟一般的建立一个TCP sever的基本思路大同小异，那么讲道理，TCP的接收数据的接口应该就是“sl_Recv”此类的函数，难道这个函数的参数“uBuf.BsdBuf”不是用于存放TCP数据包的吗？现在大致的思路应该是，使用串口中断，将接收到的数据，通过TCP的这个接口函数，发送到移动终端，就好了吧。 解决二：问题解决了，其实一直都是通的，但是这个官方的demo并没有将接收到的数据打印出来，仅仅是做了一个接收判断（即接收到数据后就亮一盏灯，然后打印出接收成功的字样）。另外，想要向手机端发送数据需要调用”sl_Send”函数，使用方式与“ sl_Recv ”类似。 问题三：现在的现象有点奇怪，两个情况下WiFi模块会无法连接：1.将开关拨到与WiFi模块相连，插上dongle，WiFi无法连接。另外，此时将开关拨到另一边，也不能连接WiFi。只有单独将WiFi模块复位才行。2.在连接上之后，发送AT+NRB，会导致WiFi断开，并再无法连接。解决办法同上，也是要将WiFi模块复位才行。根据以上现象来看，似乎是WiFi跟NB模组连接的串口导致。但是什么样的串口问题会导致这种情况呢？ 解决三：以上出现的现象原来是因为跟WiFi相连的另一路串口没有配置导致的，与NB模块LOGVIEW口相连的UART0串口，会在NB模块启动的时候收到log数据，导致WiFi模块卡死。为什么会卡死，我还不太明白，为什么没有配置的串口收到数据会导致程序卡死。 导致模块复位的原因知道了，是程序里的一个复位Pin脚占用了UART0的串口。 问题四：虽然配置好了两路的串口，但是发现，在收发AT命令的时候，两路串口好像会有干扰，导致收到的数据是乱码。之所以会这么觉得，是以为屏蔽了另一路串口问题就解决了。UART0的配置如下：1.引脚配置 123456789void PinMuxConfig(void)&#123; // Enable Peripheral Clocks MAP_PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK); MAP_PinTypeUART(PIN_03, PIN_MODE_7);//UART0 MAP_PinTypeUART(PIN_04, PIN_MODE_7);&#125; 2.串口属性配置 123456789101112131415void LOGVIEWComPort_Init_921600(void)&#123; MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8); MAP_UARTFIFOEnable(COM_P0); MAP_UARTFlowControlSet(COM_P0, UART_FLOWCONTROL_NONE); MAP_UARTConfigSetExpClk(COM_P0,MAP_PRCMPeripheralClockGet(COM_P0_PERIPH), 921600, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE)); MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler); MAP_IntPrioritySet(INT_UARTA0,INT_PRIORITY_LVL_0); MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX); &#125; 待解决四：进一步尝试，发现是这几句话会导致串口干扰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102 MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8); MAP_UARTFIFOEnable(COM_P0); MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler); MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);``` 解决四：问题原因是没有处理中断接收的数据，导致的干扰，配置好中断的处理函数之后就没有这样的问题了，不是以上这几条语句导致的。问题五：socket的数据流程整理了一下，数据结构挺庞大，好在还算清晰。简单的流程如下图：![] (https://app.yinxiang.com/shard/s62/res/14408816-1d63-434e-9576-39a18458d2c2)然后，数据是怎样从串口传到socket的呢？貌似是通过全局的队列，就是下面的这个函数，在UART的接收中断中执行``` bashvoid uart_get_char(char c)&#123; char flag = 0; portBASE_TYPE xHigherPriorityTaskWoken; uart_timer_stop(); lps_event_timer = 0; if (len_queue(&amp;g_p_uart_buf-&gt;queue) == UART_FRAME_MAX_LEN - 1) &#123; flag = 1; &#125;//队列满的情况计数，这部分代码可以复用 else if (full_quene(&amp;g_p_uart_buf-&gt;queue)) &#123; uart_bug_count++; //计数用来测试串口数据满的情况 Report("full_quene\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "full_quene\r\n"); if (g_p_uart_buf-&gt;lostNew) //丢弃最新的数据 &#123; g_uart_to_sock_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); return; &#125; else &#123; g_p_uart_buf-&gt;queue.rear = (g_p_uart_buf-&gt;queue.rear + 1) % QUEUE_SIZE; &#125; &#125; if (g_p_uart_buf-&gt;tmodeState == TMODE_CMD) &#123; if (c == '\n') //有些命令以\r\n结束 &#123; return; &#125; &#125; // 这里把串口收的数据放到这里 en_queue(&amp;g_p_uart_buf-&gt;queue, c); if (flag) &#123; g_uart_to_sock_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); &#125; else &#123; if (g_p_uart_buf-&gt;tmodeState == TMODE_CMD) &#123; if (g_p_uart_buf-&gt;echo == ECHO_ON) &#123; if('\r' != c) &#123; uart_output_byte(COM_P1, c); &#125; &#125; if (c == '\b') &#123; de_queue_font(&amp;g_p_uart_buf-&gt;queue); // delete '\b' de_queue_font(&amp;g_p_uart_buf-&gt;queue); // delete 'previous' uart_output_byte(COM_P1, ' '); uart_output_byte(COM_P1, '\b'); &#125; if (c == '\r') &#123; g_uart_to_at_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); &#125; &#125; else &#123; uart_timer_start(); &#125; &#125;&#125; 在以上存储数据的操作之后，将队列中的数据存到socket的数组中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void uart_recv_task(void *argc)&#123; uartParaStruct *pUartPara = (uartParaStruct *)argc; threadParaStruct *pThreadPara = pUartPara-&gt;para; uartBuf_typeDef *pBuf = l_v_uart_buf; char *pBufAt = NULL; unsigned short pos; int i; char existSock; while (!pThreadPara-&gt;threadCompleted) &#123; if ((l_uart_to_sock_cnt &gt; 0)) &#123; if (l_uart_to_sock_cnt &gt; 3) &#123; l_uart_to_sock_cnt = 3; &#125; pos = pBuf-&gt;queue.font; // 从串口buffer中取出数据 // 若无网络task，可以使用串口接受callback // 故每次直接从队列中取出数据，且tempbuf清楚 pBuf-&gt;tempBufLen = 0; memset(pBuf-&gt;tempBuf, 0, sizeof(pBuf-&gt;tempBuf)); do &#123; if (empty_quene(&amp;pBuf-&gt;queue)) &#123; l_uart_to_sock_cnt = 0; uart_debug("The uart queue is empty,need check code\n"); break; &#125; if (pBuf-&gt;tempBufLen &gt;= UART_FRAME_MAX_LEN) &#123; break; &#125; de_queue(&amp;pBuf-&gt;queue, &amp;pBuf-&gt;tempBuf[pBuf-&gt;tempBufLen]); pBuf-&gt;tempBufLen++; &#125; while (pos != pBuf-&gt;queue.rear); if (pBuf-&gt;tempBufLen &gt; 0) &#123; //uart callback if (pBuf-&gt;recv_callback) &#123; pBuf-&gt;tempBufLen = pBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_REDAY, (void *)pBuf, pBuf-&gt;tempBuf, pBuf-&gt;tempBufLen); &#125; //still have data,send quene to net task if (pBuf-&gt;tempBufLen &gt; 0) &#123; existSock = 0; if (g_sock_used[1] == TRUE) //当前sock建立 &#123; pBuf-&gt;sockSendLen[1] = pBuf-&gt;tempBufLen; existSock = 1; &#125; if (existSock) &#123; msleep(_DELAY_SWITCH_CONTEXT_MS); // 任务挂起，让给高优先级的sock &#125; while (1) &#123; existSock = 0; if ((g_sock_used[1] == TRUE) &amp;&amp; (g_sock_tcp[1] == TRUE)) &#123; if (pBuf-&gt;sockSendLen[1] &gt; 0) // 1 &#123; existSock = 1; &#125; &#125; if (existSock) &#123; msleep(_DELAY_FOR_WAIT_SOCK); &#125; else &#123; break; &#125; &#125; l_uart_to_sock_cnt--; &#125; else &#123; l_uart_to_sock_cnt--; &#125; &#125; &#125; else &#123; msleep(30); &#125; &#125;&#125; 最后，在socket的任务中会检测是否有数据存在，有的话就通过接口函数发送到网络 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//如果接收到了数据 if (g_p_uart_buf != NULL) &#123; if (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT) &#123; int send_len = g_p_uart_buf-&gt;sockSendLen[id]; //socka_debug("uart recv data\r\n"); //socka_debug("id=%d\r\n", id); start_time = xTaskGetTickCount(); // 获取ejoin 开始时间 //if(strlen(g_p_uart_buf-&gt;tempBuf)) ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0); first_time = xTaskGetTickCount(); LSD_Debug(LSD_DEBUG_LEVEL_3, "(%d,%u)\r\n", first_time-start_time, start_time); if ((ret &lt; 0) || (ret == 0)) &#123; socka_debug("socka send error\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "socka send error\r\n"); close(sock_fd); sock_fd = -1; pThreadPara-&gt;threadCompleted = TRUE; break; &#125; else if (send_len != ret) //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了 &#123; //网络未正常断开的时候，不能用send检测到 //这里发送失败就选择重新发送，接收的select中会检测到断网 //socka_debug("sock(%d) send fail\r\n", id); LSD_Debug(LSD_DEBUG_LEVEL_3, "sock(%d) send fail\r\n", id); if (reSendTimers++ &gt; NET_RECONNECT_TIMES) // 丢弃数据 &#123; //reSendTimers = reSendTimers; g_p_uart_buf-&gt;sockSendLen[id] = 0; &#125; else &#123; msleep(20); continue; &#125; &#125; needSleep = 0; reSendTimers = 0; g_p_uart_buf-&gt;sockSendLen[id] = 0; if(NULL != pNetBuf-&gt;recv_callback) // 150423 &#123; pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0); &#125; &#125; else &#123; // socka_debug("uart not recvd, wait...\r\n"); osi_Sleep(10); &#125; &#125;//如果接收到了数据 if (g_p_uart_buf != NULL) &#123; if (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT) &#123; int send_len = g_p_uart_buf-&gt;sockSendLen[id]; //socka_debug("uart recv data\r\n"); //socka_debug("id=%d\r\n", id); start_time = xTaskGetTickCount(); // 获取ejoin 开始时间 //if(strlen(g_p_uart_buf-&gt;tempBuf)) ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0); first_time = xTaskGetTickCount(); LSD_Debug(LSD_DEBUG_LEVEL_3, "(%d,%u)\r\n", first_time-start_time, start_time); if ((ret &lt; 0) || (ret == 0)) &#123; socka_debug("socka send error\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "socka send error\r\n"); close(sock_fd); sock_fd = -1; pThreadPara-&gt;threadCompleted = TRUE; break; &#125; else if (send_len != ret) //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了 &#123; //网络未正常断开的时候，不能用send检测到 //这里发送失败就选择重新发送，接收的select中会检测到断网 //socka_debug("sock(%d) send fail\r\n", id); LSD_Debug(LSD_DEBUG_LEVEL_3, "sock(%d) send fail\r\n", id); if (reSendTimers++ &gt; NET_RECONNECT_TIMES) // 丢弃数据 &#123; //reSendTimers = reSendTimers; g_p_uart_buf-&gt;sockSendLen[id] = 0; &#125; else &#123; msleep(20); continue; &#125; &#125; needSleep = 0; reSendTimers = 0; g_p_uart_buf-&gt;sockSendLen[id] = 0; if(NULL != pNetBuf-&gt;recv_callback) // 150423 &#123; pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0); &#125; &#125; else &#123; // socka_debug("uart not recvd, wait...\r\n"); osi_Sleep(10); &#125; &#125; 现在遇到的麻烦是，开启sockB的时候，会导致堆栈溢出。 很好，堆栈溢出的问题解决了，原因是任务分配的内存大小不够，sockB的任务。 然而，新的问题又出现了，使用sockB无法连接。 最新问题，当数据大于等于512个字节时，队列的缓冲区就满了，很奇怪，明明分配了0x1600的空间，却用不到那么空间。 解决五： 上述问题都解决了，但实际上还遗留着一个问题，就是使用socketB作为lowview的数据通道时，串口中断的队列会溢出。现在的做法是，将socketB换成了AT命令的数据通道。问题得以规避。原因却没有找到，大概是socketB发送数据时出队的设计这边有些问题，支撑不了这么快的数据。 问题六： AT串口出现断包的现象，想想是什么原因吧，可是NB模块又是返回正确的数据长度以及OK，然而服务器那边却收不到断了的数据包。这是为什么？明天早上先把串口换一下试试。 解决六： 接收断包的现象可能跟WiFi模块的信号有关，使用手机做热点的时候并不会有这种现象，并且，这现象只发生在模块刚启动的一会儿，过一会就不再有这种情况。]]></content>
      <categories>
        <category>CC32xx系列开发</category>
      </categories>
      <tags>
        <tag>CC3200</tag>
        <tag>单片机</tag>
        <tag>WiFi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[va_start和va_end使用详解]]></title>
    <url>%2F2018%2F06%2F01%2Fva_start%E5%92%8Cva_end%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表 void foo(…);void foo(parm_list,…);这种方式和我们以前认识的不大一样，但我们要记住这是C中一种传参的形式，在后面我们就会用到它。 2.函数参数的传递原理 函数参数是以数据结构:栈的形式存取,从右至左入栈。 首先是参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址，举个例子如下：void func(int x, float y, char z); 那么，调用函数的时候，实参 char z 先进栈，然后是 float y，最后是 int x，因此在内存中变量的存放次序是 x-&gt;y-&gt;z，因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过指针移位运算，则总可以顺藤摸瓜找到其他的输入变量。 下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：typedef char va_list;void va_start ( va_list ap, prev_param ); / ANSI version */type va_arg ( va_list ap, type );void va_end ( va_list ap );va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)； 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数； 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置； 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。 example123456789101112131415161718192021222324#include &lt;iostream.h&gt; void fun(int a, ...) &#123; int *temp = &amp;a; temp++; for (int i = 0; i &lt; a; ++i) &#123; cout &lt;&lt; *temp &lt;&lt; endl; temp++; &#125; &#125;int main() &#123; int a = 1; int b = 2; int c = 3; int d = 4; fun(4, a, b, c, d); system("pause"); return 0; &#125; Output:: 1 2 3 4 3:获取省略号指定的参数 在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。像这段代码： 12345678910111213141516171819202122232425262728293031323334353637void TestFun(char* pszDest, int DestLen, const char* pszFormat, ...) &#123; va_list args; va_start(args, pszFormat); //一定要“...”之前的那个参数_vsnprintf(pszDest, DestLen, pszFormat, args); va_end(args); &#125; 4.演示如何使用参数个数可变的函数，采用ANSI标准形式 #include 〈stdio.h〉 #include 〈string.h〉 #include 〈stdarg.h〉 /*函数原型声明，至少需要一个确定的参数，注意括号内的省略号*/ int demo( char, ... ); void main( void ) &#123; demo("DEMO", "This", "is", "a", "demo!", ""); &#125; /*ANSI标准形式的声明方式，括号内的省略号表示可选参数*/ int demo( char msg, ... ) &#123; /*定义保存函数参数的结构*/ va_list argp; int argno = 0; char para; /*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/ va_start( argp, msg ); while (1) &#123; para = va_arg( argp, char); if ( strcmp( para, "") == 0 ) break; printf("Parameter #%d is: %s\n", argno, para); argno++; &#125; va_end( argp ); /*将argp置为NULL*/return 0; &#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数函数用法]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[exampletypedef char* va_list;//用于声明一个指向参数列表的字符型指针变量void va_start(va_list ap,prev_param);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的第一个参数，通常用于指定可变参数列表中参数的个数void va_arg(va_list ap,type);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的数据类型void va_end(va_list ap);//将存放可变参数字符串的变量清空（赋值为NULL） 123456789101112131415161718int sum(int count,...)//计算和&#123; int sum = 0; int i; va_list ap; va_start(ap,count); for(i=0;i&lt;count;++i) &#123; sum+=va_arg(ap,int); &#125; va_end(ap); return sum;&#125;int main()&#123; printf("%d\r\n",sum(3,1,2,3));&#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于回调函数的理解]]></title>
    <url>%2F2018%2F05%2F26%2F%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[example实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。 实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。 populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。 12345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; // 回调函数 void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) &#123; for (size_t i=0; i&lt;arraySize; i++) array[i] = getNextValue(); &#125; // 获取随机值 int getNextRandomValue(void) &#123; return rand(); &#125; int main(void) &#123; int myarray[10];//此处getNextValue指向 getNextRandomValue函数的地址，起到调用作用 populate_array(myarray, 10, getNextRandomValue); for(int i = 0; i &lt; 10; i++) &#123; printf("%d ", myarray[i]); &#125; printf("\n"); return 0; &#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
