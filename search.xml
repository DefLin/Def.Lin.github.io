<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于CC3200实现WiFi Direct]]></title>
    <url>%2F2018%2F06%2F05%2F%E5%9F%BA%E4%BA%8ECC3200%E5%AE%9E%E7%8E%B0WiFi%20Direct%2F</url>
    <content type="text"><![CDATA[遇到的问题与解决没接触过这类板子，有点陌生，不要紧，一步一步来。问题一：1.烧写了官方的SDK，按照提示，通过WiFi直连连接到了手机，但是失败概率很高，使用华为P10和魅蓝5连接不上，换用华为Nova2可以较为轻松的连上，暂时不知道是什么原因。2.在网上下载了几个APP：serial WiFi，WiFi TCP/UDP，可以连接到cc3200，但是无法数据通信。想知道是否需要TI官方相关的配套APP才可以。 解决一：下载了个APP“magic iperf”,好像是有了点作用，串口打印出已经收到TCP数据，然而没有打印出接收到的数据啊。 问题二：修改了程序，输出了接收缓冲区，但是输出的内容让人摸不着头脑。怎么看都不像是正常的数据包。现在最大的问题，应该怎样通过手机给模块发送TCP数据，并且通过串口打印输出到电脑上。代码里面找不到相关的内容，只有socket的创建，绑定端口等操作，在一个叫“BsdTcpServer”的函数里。这个函数，跟一般的建立一个TCP sever的基本思路大同小异，那么讲道理，TCP的接收数据的接口应该就是“sl_Recv”此类的函数，难道这个函数的参数“uBuf.BsdBuf”不是用于存放TCP数据包的吗？现在大致的思路应该是，使用串口中断，将接收到的数据，通过TCP的这个接口函数，发送到移动终端，就好了吧。 解决二：问题解决了，其实一直都是通的，但是这个官方的demo并没有将接收到的数据打印出来，仅仅是做了一个接收判断（即接收到数据后就亮一盏灯，然后打印出接收成功的字样）。另外，想要向手机端发送数据需要调用”sl_Send”函数，使用方式与“ sl_Recv ”类似。 问题三：现在的现象有点奇怪，两个情况下WiFi模块会无法连接：1.将开关拨到与WiFi模块相连，插上dongle，WiFi无法连接。另外，此时将开关拨到另一边，也不能连接WiFi。只有单独将WiFi模块复位才行。2.在连接上之后，发送AT+NRB，会导致WiFi断开，并再无法连接。解决办法同上，也是要将WiFi模块复位才行。根据以上现象来看，似乎是WiFi跟NB模组连接的串口导致。但是什么样的串口问题会导致这种情况呢？ 解决三：以上出现的现象原来是因为跟WiFi相连的另一路串口没有配置导致的，与NB模块LOGVIEW口相连的UART0串口，会在NB模块启动的时候收到log数据，导致WiFi模块卡死。为什么会卡死，我还不太明白，为什么没有配置的串口收到数据会导致程序卡死。 导致模块复位的原因知道了，是程序里的一个复位Pin脚占用了UART0的串口。 问题四：虽然配置好了两路的串口，但是发现，在收发AT命令的时候，两路串口好像会有干扰，导致收到的数据是乱码。之所以会这么觉得，是以为屏蔽了另一路串口问题就解决了。UART0的配置如下：1.引脚配置 123456789void PinMuxConfig(void)&#123; // Enable Peripheral Clocks MAP_PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK); MAP_PinTypeUART(PIN_03, PIN_MODE_7);//UART0 MAP_PinTypeUART(PIN_04, PIN_MODE_7);&#125; 2.串口属性配置 123456789101112131415void LOGVIEWComPort_Init_921600(void)&#123; MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8); MAP_UARTFIFOEnable(COM_P0); MAP_UARTFlowControlSet(COM_P0, UART_FLOWCONTROL_NONE); MAP_UARTConfigSetExpClk(COM_P0,MAP_PRCMPeripheralClockGet(COM_P0_PERIPH), 921600, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE)); MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler); MAP_IntPrioritySet(INT_UARTA0,INT_PRIORITY_LVL_0); MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX); &#125; 待解决四：进一步尝试，发现是这几句话会导致串口干扰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102 MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8); MAP_UARTFIFOEnable(COM_P0); MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler); MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);``` 解决四：问题原因是没有处理中断接收的数据，导致的干扰，配置好中断的处理函数之后就没有这样的问题了，不是以上这几条语句导致的。问题五：socket的数据流程整理了一下，数据结构挺庞大，好在还算清晰。简单的流程如下图：![] (https://app.yinxiang.com/shard/s62/res/14408816-1d63-434e-9576-39a18458d2c2)然后，数据是怎样从串口传到socket的呢？貌似是通过全局的队列，就是下面的这个函数，在UART的接收中断中执行``` bashvoid uart_get_char(char c)&#123; char flag = 0; portBASE_TYPE xHigherPriorityTaskWoken; uart_timer_stop(); lps_event_timer = 0; if (len_queue(&amp;g_p_uart_buf-&gt;queue) == UART_FRAME_MAX_LEN - 1) &#123; flag = 1; &#125;//队列满的情况计数，这部分代码可以复用 else if (full_quene(&amp;g_p_uart_buf-&gt;queue)) &#123; uart_bug_count++; //计数用来测试串口数据满的情况 Report("full_quene\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "full_quene\r\n"); if (g_p_uart_buf-&gt;lostNew) //丢弃最新的数据 &#123; g_uart_to_sock_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); return; &#125; else &#123; g_p_uart_buf-&gt;queue.rear = (g_p_uart_buf-&gt;queue.rear + 1) % QUEUE_SIZE; &#125; &#125; if (g_p_uart_buf-&gt;tmodeState == TMODE_CMD) &#123; if (c == '\n') //有些命令以\r\n结束 &#123; return; &#125; &#125; // 这里把串口收的数据放到这里 en_queue(&amp;g_p_uart_buf-&gt;queue, c); if (flag) &#123; g_uart_to_sock_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); &#125; else &#123; if (g_p_uart_buf-&gt;tmodeState == TMODE_CMD) &#123; if (g_p_uart_buf-&gt;echo == ECHO_ON) &#123; if('\r' != c) &#123; uart_output_byte(COM_P1, c); &#125; &#125; if (c == '\b') &#123; de_queue_font(&amp;g_p_uart_buf-&gt;queue); // delete '\b' de_queue_font(&amp;g_p_uart_buf-&gt;queue); // delete 'previous' uart_output_byte(COM_P1, ' '); uart_output_byte(COM_P1, '\b'); &#125; if (c == '\r') &#123; g_uart_to_at_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); &#125; &#125; else &#123; uart_timer_start(); &#125; &#125;&#125; 在以上存储数据的操作之后，将队列中的数据存到socket的数组中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void uart_recv_task(void *argc)&#123; uartParaStruct *pUartPara = (uartParaStruct *)argc; threadParaStruct *pThreadPara = pUartPara-&gt;para; uartBuf_typeDef *pBuf = l_v_uart_buf; char *pBufAt = NULL; unsigned short pos; int i; char existSock; while (!pThreadPara-&gt;threadCompleted) &#123; if ((l_uart_to_sock_cnt &gt; 0)) &#123; if (l_uart_to_sock_cnt &gt; 3) &#123; l_uart_to_sock_cnt = 3; &#125; pos = pBuf-&gt;queue.font; // 从串口buffer中取出数据 // 若无网络task，可以使用串口接受callback // 故每次直接从队列中取出数据，且tempbuf清楚 pBuf-&gt;tempBufLen = 0; memset(pBuf-&gt;tempBuf, 0, sizeof(pBuf-&gt;tempBuf)); do &#123; if (empty_quene(&amp;pBuf-&gt;queue)) &#123; l_uart_to_sock_cnt = 0; uart_debug("The uart queue is empty,need check code\n"); break; &#125; if (pBuf-&gt;tempBufLen &gt;= UART_FRAME_MAX_LEN) &#123; break; &#125; de_queue(&amp;pBuf-&gt;queue, &amp;pBuf-&gt;tempBuf[pBuf-&gt;tempBufLen]); pBuf-&gt;tempBufLen++; &#125; while (pos != pBuf-&gt;queue.rear); if (pBuf-&gt;tempBufLen &gt; 0) &#123; //uart callback if (pBuf-&gt;recv_callback) &#123; pBuf-&gt;tempBufLen = pBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_REDAY, (void *)pBuf, pBuf-&gt;tempBuf, pBuf-&gt;tempBufLen); &#125; //still have data,send quene to net task if (pBuf-&gt;tempBufLen &gt; 0) &#123; existSock = 0; if (g_sock_used[1] == TRUE) //当前sock建立 &#123; pBuf-&gt;sockSendLen[1] = pBuf-&gt;tempBufLen; existSock = 1; &#125; if (existSock) &#123; msleep(_DELAY_SWITCH_CONTEXT_MS); // 任务挂起，让给高优先级的sock &#125; while (1) &#123; existSock = 0; if ((g_sock_used[1] == TRUE) &amp;&amp; (g_sock_tcp[1] == TRUE)) &#123; if (pBuf-&gt;sockSendLen[1] &gt; 0) // 1 &#123; existSock = 1; &#125; &#125; if (existSock) &#123; msleep(_DELAY_FOR_WAIT_SOCK); &#125; else &#123; break; &#125; &#125; l_uart_to_sock_cnt--; &#125; else &#123; l_uart_to_sock_cnt--; &#125; &#125; &#125; else &#123; msleep(30); &#125; &#125;&#125; 最后，在socket的任务中会检测是否有数据存在，有的话就通过接口函数发送到网络 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//如果接收到了数据 if (g_p_uart_buf != NULL) &#123; if (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT) &#123; int send_len = g_p_uart_buf-&gt;sockSendLen[id]; //socka_debug("uart recv data\r\n"); //socka_debug("id=%d\r\n", id); start_time = xTaskGetTickCount(); // 获取ejoin 开始时间 //if(strlen(g_p_uart_buf-&gt;tempBuf)) ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0); first_time = xTaskGetTickCount(); LSD_Debug(LSD_DEBUG_LEVEL_3, "(%d,%u)\r\n", first_time-start_time, start_time); if ((ret &lt; 0) || (ret == 0)) &#123; socka_debug("socka send error\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "socka send error\r\n"); close(sock_fd); sock_fd = -1; pThreadPara-&gt;threadCompleted = TRUE; break; &#125; else if (send_len != ret) //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了 &#123; //网络未正常断开的时候，不能用send检测到 //这里发送失败就选择重新发送，接收的select中会检测到断网 //socka_debug("sock(%d) send fail\r\n", id); LSD_Debug(LSD_DEBUG_LEVEL_3, "sock(%d) send fail\r\n", id); if (reSendTimers++ &gt; NET_RECONNECT_TIMES) // 丢弃数据 &#123; //reSendTimers = reSendTimers; g_p_uart_buf-&gt;sockSendLen[id] = 0; &#125; else &#123; msleep(20); continue; &#125; &#125; needSleep = 0; reSendTimers = 0; g_p_uart_buf-&gt;sockSendLen[id] = 0; if(NULL != pNetBuf-&gt;recv_callback) // 150423 &#123; pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0); &#125; &#125; else &#123; // socka_debug("uart not recvd, wait...\r\n"); osi_Sleep(10); &#125; &#125;//如果接收到了数据 if (g_p_uart_buf != NULL) &#123; if (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT) &#123; int send_len = g_p_uart_buf-&gt;sockSendLen[id]; //socka_debug("uart recv data\r\n"); //socka_debug("id=%d\r\n", id); start_time = xTaskGetTickCount(); // 获取ejoin 开始时间 //if(strlen(g_p_uart_buf-&gt;tempBuf)) ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0); first_time = xTaskGetTickCount(); LSD_Debug(LSD_DEBUG_LEVEL_3, "(%d,%u)\r\n", first_time-start_time, start_time); if ((ret &lt; 0) || (ret == 0)) &#123; socka_debug("socka send error\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "socka send error\r\n"); close(sock_fd); sock_fd = -1; pThreadPara-&gt;threadCompleted = TRUE; break; &#125; else if (send_len != ret) //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了 &#123; //网络未正常断开的时候，不能用send检测到 //这里发送失败就选择重新发送，接收的select中会检测到断网 //socka_debug("sock(%d) send fail\r\n", id); LSD_Debug(LSD_DEBUG_LEVEL_3, "sock(%d) send fail\r\n", id); if (reSendTimers++ &gt; NET_RECONNECT_TIMES) // 丢弃数据 &#123; //reSendTimers = reSendTimers; g_p_uart_buf-&gt;sockSendLen[id] = 0; &#125; else &#123; msleep(20); continue; &#125; &#125; needSleep = 0; reSendTimers = 0; g_p_uart_buf-&gt;sockSendLen[id] = 0; if(NULL != pNetBuf-&gt;recv_callback) // 150423 &#123; pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0); &#125; &#125; else &#123; // socka_debug("uart not recvd, wait...\r\n"); osi_Sleep(10); &#125; &#125; 现在遇到的麻烦是，开启sockB的时候，会导致堆栈溢出。 很好，堆栈溢出的问题解决了，原因是任务分配的内存大小不够，sockB的任务。 然而，新的问题又出现了，使用sockB无法连接。 最新问题，当数据大于等于512个字节时，队列的缓冲区就满了，很奇怪，明明分配了0x1600的空间，却用不到那么空间。 解决五： 上述问题都解决了，但实际上还遗留着一个问题，就是使用socketB作为lowview的数据通道时，串口中断的队列会溢出。现在的做法是，将socketB换成了AT命令的数据通道。问题得以规避。原因却没有找到，大概是socketB发送数据时出队的设计这边有些问题，支撑不了这么快的数据。 问题六： AT串口出现断包的现象，想想是什么原因吧，可是NB模块又是返回正确的数据长度以及OK，然而服务器那边却收不到断了的数据包。这是为什么？明天早上先把串口换一下试试。 解决六： 接收断包的现象可能跟WiFi模块的信号有关，使用手机做热点的时候并不会有这种现象，并且，这现象只发生在模块刚启动的一会儿，过一会就不再有这种情况。]]></content>
      <categories>
        <category>CC32xx系列开发</category>
      </categories>
      <tags>
        <tag>CC3200</tag>
        <tag>单片机</tag>
        <tag>WiFi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[va_start和va_end使用详解]]></title>
    <url>%2F2018%2F06%2F01%2Fva_start%E5%92%8Cva_end%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表 void foo(…);void foo(parm_list,…);这种方式和我们以前认识的不大一样，但我们要记住这是C中一种传参的形式，在后面我们就会用到它。 2.函数参数的传递原理 函数参数是以数据结构:栈的形式存取,从右至左入栈。 首先是参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址，举个例子如下：void func(int x, float y, char z); 那么，调用函数的时候，实参 char z 先进栈，然后是 float y，最后是 int x，因此在内存中变量的存放次序是 x-&gt;y-&gt;z，因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过指针移位运算，则总可以顺藤摸瓜找到其他的输入变量。 下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：typedef char va_list;void va_start ( va_list ap, prev_param ); / ANSI version */type va_arg ( va_list ap, type );void va_end ( va_list ap );va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)； 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数； 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置； 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。 example123456789101112131415161718192021222324#include &lt;iostream.h&gt; void fun(int a, ...) &#123; int *temp = &amp;a; temp++; for (int i = 0; i &lt; a; ++i) &#123; cout &lt;&lt; *temp &lt;&lt; endl; temp++; &#125; &#125;int main() &#123; int a = 1; int b = 2; int c = 3; int d = 4; fun(4, a, b, c, d); system("pause"); return 0; &#125; Output:: 1 2 3 4 3:获取省略号指定的参数 在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。像这段代码： 12345678910111213141516171819202122232425262728293031323334353637void TestFun(char* pszDest, int DestLen, const char* pszFormat, ...) &#123; va_list args; va_start(args, pszFormat); //一定要“...”之前的那个参数_vsnprintf(pszDest, DestLen, pszFormat, args); va_end(args); &#125; 4.演示如何使用参数个数可变的函数，采用ANSI标准形式 #include 〈stdio.h〉 #include 〈string.h〉 #include 〈stdarg.h〉 /*函数原型声明，至少需要一个确定的参数，注意括号内的省略号*/ int demo( char, ... ); void main( void ) &#123; demo("DEMO", "This", "is", "a", "demo!", ""); &#125; /*ANSI标准形式的声明方式，括号内的省略号表示可选参数*/ int demo( char msg, ... ) &#123; /*定义保存函数参数的结构*/ va_list argp; int argno = 0; char para; /*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/ va_start( argp, msg ); while (1) &#123; para = va_arg( argp, char); if ( strcmp( para, "") == 0 ) break; printf("Parameter #%d is: %s\n", argno, para); argno++; &#125; va_end( argp ); /*将argp置为NULL*/return 0; &#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数函数用法]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[exampletypedef char* va_list;//用于声明一个指向参数列表的字符型指针变量void va_start(va_list ap,prev_param);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的第一个参数，通常用于指定可变参数列表中参数的个数void va_arg(va_list ap,type);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的数据类型void va_end(va_list ap);//将存放可变参数字符串的变量清空（赋值为NULL） 123456789101112131415161718int sum(int count,...)//计算和&#123; int sum = 0; int i; va_list ap; va_start(ap,count); for(i=0;i&lt;count;++i) &#123; sum+=va_arg(ap,int); &#125; va_end(ap); return sum;&#125;int main()&#123; printf("%d\r\n",sum(3,1,2,3));&#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于回调函数的理解]]></title>
    <url>%2F2018%2F05%2F26%2F%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[example实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。 实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。 populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。 12345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; // 回调函数 void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) &#123; for (size_t i=0; i&lt;arraySize; i++) array[i] = getNextValue(); &#125; // 获取随机值 int getNextRandomValue(void) &#123; return rand(); &#125; int main(void) &#123; int myarray[10];//此处getNextValue指向 getNextRandomValue函数的地址，起到调用作用 populate_array(myarray, 10, getNextRandomValue); for(int i = 0; i &lt; 10; i++) &#123; printf("%d ", myarray[i]); &#125; printf("\n"); return 0; &#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
