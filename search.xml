<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[lwip上实现TCP客户端]]></title>
    <url>%2F2019%2F03%2F12%2Flwip%E4%B8%8A%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[lwip上实现TCP客户端上一篇中讲到了使用NB-IoT模组实现TCP通讯，只是实现了上层应用，通过了解才知道，要在MCU上实现TCP还得借助lwip的协议栈，这一篇主要就来探究这个问题。先实现一个简单的主函数12345678910int main(void)&#123; System_Setup(); LwIP_Init(); Client_init(); while (1) &#123; LwIP_Periodic_Handle(LocalTime); &#125;&#125; 关键在于Client_init()这个函数12345678910void Client_init(void)&#123; struct tcp_pcb *pcb; struct ip_addr ipaddr; IP4_ADDR(&amp;ipaddr,192,168,0,22); //远程服务器IP 写进全局变量 pcb = tcp_new(); //建立一个新的tcp 链接 tcp_bind(pcb, IP_ADDR_ANY, 23);//绑定开发板IP和端口号 这里端口号可以是0 也就是随机，因为是客户端 不必知道端口号。 tcp_connect(pcb, &amp;ipaddr, PEER_PORT, tcp_Client_connected);//这里和服务器不太一样，服务器模式是监听listen，客户端的话 就要主动去连接服务器&#125; 分析一下参数含义：123456789101112131415161718192021222324252627282930313233343536373839404142PCB //就是前面建立的tcp端口IPADDR //要连接的远程服务器IP 这里设置的是测试的电脑的IP,这里设置的是 IP4_ADDR(&amp;ipaddr,192,168,0,22);PEER_PORT //远程端口号,要连接的端口号,这里设置的是5000tcp_Client_connected //连接到远程服务器成功后的回调函数,连接成功后会调用这个函数//由下面这个函数调用err_ttcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port, err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))&#123; err_t ret; u32_t iss; LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb-&gt;state == CLOSED, return ERR_ISCONN); LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port)); if (ipaddr != NULL) &#123; pcb-&gt;remote_ip = *ipaddr; //远程IP &#125; else &#123; return ERR_VAL; &#125; pcb-&gt;remote_port = port; //端口号 if (pcb-&gt;local_port == 0) &#123; pcb-&gt;local_port = tcp_new_port();//本地端口号 &#125; iss = tcp_next_iss(); pcb-&gt;rcv_nxt = 0; pcb-&gt;snd_nxt = iss; pcb-&gt;lastack = iss - 1; pcb-&gt;snd_lbb = iss - 1; pcb-&gt;rcv_wnd = TCP_WND; pcb-&gt;rcv_ann_wnd = TCP_WND; pcb-&gt;rcv_ann_right_edge = pcb-&gt;rcv_nxt; pcb-&gt;snd_wnd = TCP_WND; /* As initial send MSS, we use TCP_MSS but limit it to 536. The send MSS is updated when an MSS option is received. */ pcb-&gt;mss = (TCP_MSS &gt; 536) ? 536 : TCP_MSS;#if TCP_CALCULATE_EFF_SEND_MSS pcb-&gt;mss = tcp_eff_send_mss(pcb-&gt;mss, ipaddr);#endif /* TCP_CALCULATE_EFF_SEND_MSS */ pcb-&gt;cwnd = 1; pcb-&gt;ssthresh = pcb-&gt;mss * 10; pcb-&gt;state = SYN_SENT;#if LWIP_CALLBACK_API pcb-&gt;connected = connected;//回调函数传递给我们网络端口connected 在”TCP.h”文件中判断是否连接成功，具体函数如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define TCP_EVENT_CONNECTED(pcb,err,ret) \ do &#123; \ if((pcb)-&gt;connected != NULL) \ (ret) = (pcb)-&gt;connected((pcb)-&gt;callback_arg,(pcb),(err)); \ else (ret) = ERR_OK; \ &#125; while (0)//搜索TCP_EVENT_CONNECTED就能找到连接远程服务器成功后,程序到了哪里,并且调用了我们的回调函数。 //然后，就能在tcp_process(struct tcp_pcb *pcb)函数中找到switch (pcb-&gt;state) &#123; case SYN_SENT: LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb-&gt;snd_nxt %"U32_F" unacked %"U32_F"\n", ackno, pcb-&gt;snd_nxt, ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno))); /* received SYN ACK with expected sequence number? */ if ((flags &amp; TCP_ACK) &amp;&amp; (flags &amp; TCP_SYN) &amp;&amp; ackno == ntohl(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno) + 1) &#123; pcb-&gt;snd_buf++; pcb-&gt;rcv_nxt = seqno + 1; pcb-&gt;rcv_ann_right_edge = pcb-&gt;rcv_nxt; pcb-&gt;lastack = ackno; pcb-&gt;snd_wnd = tcphdr-&gt;wnd; pcb-&gt;snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */ pcb-&gt;state = ESTABLISHED;#if TCP_CALCULATE_EFF_SEND_MSS pcb-&gt;mss = tcp_eff_send_mss(pcb-&gt;mss, &amp;(pcb-&gt;remote_ip));#endif /* TCP_CALCULATE_EFF_SEND_MSS */ /* Set ssthresh again after changing pcb-&gt;mss (already set in tcp_connect * but for the default value of pcb-&gt;mss) */ pcb-&gt;ssthresh = pcb-&gt;mss * 10; pcb-&gt;cwnd = ((pcb-&gt;cwnd == 1) ? (pcb-&gt;mss * 2) : pcb-&gt;mss); LWIP_ASSERT("pcb-&gt;snd_queuelen &gt; 0", (pcb-&gt;snd_queuelen &gt; 0)); --pcb-&gt;snd_queuelen; LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb-&gt;snd_queuelen)); rseg = pcb-&gt;unacked; pcb-&gt;unacked = rseg-&gt;next; /* If there's nothing left to acknowledge, stop the retransmit timer, otherwise reset it to start again */ if(pcb-&gt;unacked == NULL) pcb-&gt;rtime = -1; else &#123; pcb-&gt;rtime = 0; pcb-&gt;nrtx = 0; &#125; tcp_seg_free(rseg); /* Call the user specified function to call when sucessfully * connected. */ TCP_EVENT_CONNECTED(pcb, ERR_OK, err); //就是这里,接收到服务器的回应 tcp_ack_now(pcb); &#125;#endif /* LWIP_CALLBACK_API */ TCP_RMV(&amp;tcp_bound_pcbs, pcb); TCP_REG(&amp;tcp_active_pcbs, pcb); snmp_inc_tcpactiveopens();ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS#if LWIP_TCP_TIMESTAMPS | TF_SEG_OPTS_TS#endif ); if (ret == ERR_OK) &#123; tcp_output(pcb); &#125; return ret;&#125;]]></content>
      <categories>
        <category>lwip</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NB-IoT上实现TCP连接]]></title>
    <url>%2F2019%2F03%2F12%2FNB-IoT%E4%B8%8A%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[NB-IoT上实现TCP连接首先创建网络初始化任务（netWorkTask），根据配置，通过AT命令配置成TCP协议。配置TCP协议过程如下： 一、配置TCP的IP地址，地址参数通过initTCP接口函数传入。二、配置TCP的端口号，同样由以上函数传入。三、初始化NB的IP：1、调用bs_connect函数，此函数的主要功能是：设置手机的全功能打开（CFUN=1）；如果是CoAP协议的话，还须设置NCDP ;查询IMEI号；重启；打开错误提示；开启自动上报；GPRS附着；设置连接基站；通过查询IP（CGPADDR）判断是否联网。 2、创建IPSocket(createipsocket):清除接收缓冲区；向模组发送AT+NSOCL命令；判断是否创建成功，若成功就返回socket_num，通过串口打印。 3、令receive_type等于Rec_IP四、判断是否初始化成功，如果不成功，初始化LWIP（LwIP_Init()）发送LWIP信号量，然后调用lwip_tcp_init函数，初始化TCP客户端tcp_client_init（）：1、配置服务器IP地址；2、调用tcp_new()函数,该函数调用的是tcp_alloc函数，其作用是分配一个新的tcp_pcb结构；（具体内容参考网上详细资料，这 里不做赘述）3、将新分配的pcb结构赋值TPCD变量。4、如果上述的pcb不为空，那么将nb_ip和tcp_port绑定，这里调用tcp_bind(tpcb, &amp;nb_ip, tcp_port)函数实现。5、若绑定函数返回成功，则建立tcp连接，调用tcp_connect(tpcb, &amp;ipaddr, tcp_port, tcp_client_accept)函数。其中 tcp_client_accept 函数中调用了tcp_recv(tpcb, tcp_client_recv)来获取tcp的接收内容。 而这一过程是由tcp_client_recv函数实现的： 通过调用 tcp_recved 函数将接收到的数据存到 p-&gt;payload地址下tcp_recved(tpcb, p-&gt;tot_len) 通过onGetData(p-&gt;payload,p-&gt;len)函数，将接收到的数据回传。回传的数据存到pgetData变量中。 清空接收缓冲区 其次完成上述配置过程之后，设置TCP数据的回调函数，setGetTCPDataCallBack(getInputData)。 getInputData 函数的作用是检查服务器是否有应答。]]></content>
      <categories>
        <category>NB-IoT</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiteOS——消息队列使用]]></title>
    <url>%2F2019%2F03%2F08%2FLiteOS%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[LiteOS——消息队列使用1.声明队列名称例如：1static osMessageQueueId_t dns_incoming_queue = NULL; 2.创建队列例如：123456789void dns_create_queue(void)&#123; dns_incoming_queue = osMessageQueueNew(DNS_MAIN_MSG_QUEUE_LEN, DNS_MAIN_QUEUE_ITEM_SIZE, NULL); if(NULL == dns_incoming_queue) &#123; APP_COAP_ERROR("creat dns queue f"); &#125; return;&#125; 3.发送消息例如：1234void dns_send_to_incoming_queue(uint32 state)&#123; (void)osMessageQueuePut(dns_incoming_queue, (void*)&amp;state, 0, osWaitForever);&#125; 4.接收消息例如：1if (osMessageQueueGet(dns_incoming_queue, (void*)&amp;queue_msg, NULL, osWaitForever) == osOK)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>LiteOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiteOS——信号量使用]]></title>
    <url>%2F2019%2F03%2F08%2FLiteOS%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[LiteOS——信号量使用信号量的使用：12345678osMutexNew（）；//创建信号量osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout)//接收信号量osStatus_t osMutexRelease (osMutexId_t mutex_id)//释放信号量``` ### 1.声明一个信号量例如：``` cpp static osMutexId_t app_at_asyc_semaphore = NULL; 2.创建信号量例如：12345678void app_at_async_notify_init(void)&#123; app_at_asyc_semaphore = osMutexNew(NULL); if (!app_at_asyc_semaphore) &#123; assert(false); &#125;&#125; 3.释放信号量例如：1234567static void app_at_asnyc_give_semaphore(void)&#123; if (osMutexRelease(app_at_asyc_semaphore) != osOK) &#123; assert(false); &#125;&#125; 4.获取信号量例如：1234567static void app_at_asnyc_take_semaphore(void)&#123; if(osMutexAcquire(app_at_asyc_semaphore, osWaitForever) != osOK) &#123; assert(false); &#125;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>LiteOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diff和patch用法]]></title>
    <url>%2F2019%2F03%2F07%2Fdiff%E5%92%8Cpatch%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[diff和patch用法diff和patch是一对工具，在数学上来说，diff是对两个集合的差运算，patch是对两个集合的和运算。diff比较两个文件或文件集合的差异，并记录下来，生成一个diff文件，这也是我们常说的patch文件，即补丁文件。patch能将diff文件运用于 原来的两个集合之一，从而得到另一个集合。举个例子来说文件A和文件B,经过diff之后生成了补丁文件C,那么着个过程相当于 A -B = C ,那么patch的过程就是B+C = A 或A-C =B。因此我们只要能得到A, B, C三个文件中的任何两个，就能用diff和patch这对工具生成另外一个文件。这就是diff和patch的妙处。下面分别介绍一下两个工具的用法。 1. diff的用法diff后面可以接两个文件名或两个目录名。 如果是一个目录名加一个文件名，那么只作用在那么个目录下的同名文件。如果是两个目录的话，作用于该目录下的所有文件，不递归。如果我们希望递归执行，需要使用-r参数。命令diff A B &gt; C ,一般A是原始文件，B是修改后的文件，C称为A的补丁文件。不加任何参数生成的diff文件格式是一种简单的格式，这种格式只标出了不一样的行数和内容。我们需要一种更详细的格式，可以标识出不同之处的上下文环境，这样更有利于提高patch命令的识别能力。这个时候可以用-c开关。 2. patch的用法patch用于根据原文件和补丁文件生成目标文件。还是拿上个例子来说：patch A C 就能得到B, 这一步叫做对A打上了B的名字为C的补丁。进一步之后，你的文件A就变成了文件B。如果你打完补丁之后想恢复到A怎么办呢？patch -R B C 就可以重新还原到A了。所以不用担心会失去A的问题。其实patch在具体使用的时候是不用指定原文件的，因为补丁文件中都已经记载了原文件的路径和名称。patch足够聪明可以认出来。但是有时候会 有点小问题。比如一般对两个目录diff的时候可能已经包含了原目录的名字，但是我们打补丁的时候会进入到目录中再使用patch,着个时候就需要你告诉 patch命令怎么处理补丁文件中的路径。可以利用-pn开关，告诉patch命令忽略的路径分隔符的个数。举例如下：A文件在 DIR_A下，修改后的B文件在DIR_B下，一般DIR_A和DIR_B在同一级目录。我们为了对整个目录下的所有文件一次性diff,我们一般会到DIR_A和DIR_B的父目录下执行以下命令 diff -rc DIR_A DIR_B &gt; C 着个时候补丁文件C中会记录了原始文件的路径为 DIR_A/A现在另一个用户得到了A文件和C文件，其中A文件所在的目录也是DIR_A。 一般，他会比较喜欢在DIR_A目录下面进行patch操作，它会执行 patch &lt; C 但是这个时候patch分析C文件中的记录，认为原始文件是./DIR_A/A，但实际上是./A，此时patch会找不到原始文件。为了避免这种情况我们可以使用-p1参数如下 patch -p1 &lt; C 此时，patch会忽略掉第1个”/”之前的内容，认为原始文件是 ./A，这样就正确了。最后有以下几点注意： 1. 一次打多个patch的话，一般这些patch有先后顺序，得按次序打才行。 2. 在patch之前不要对原文件进行任何修改 3. 如果patch中记录的原始文件和你得到的原始文件版本不匹配(很容易出现)，那么你可以尝试使用patch, 如果幸运的话，可以成功。大部分情况下，会有不匹配的情况，此时patch会生成rej文件，记录失败的地方，你可以手工修改。]]></content>
      <categories>
        <category>脚本语言</category>
      </categories>
      <tags>
        <tag>脚本语言</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读代码]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[收集所有可能收集的材料阅读代码要做的第一件事情是收集所有和项目相关的资料。比如你要做一个项目的售后服务，那么你首先要搞明白项目做什么用的，那么调研文档、概要设计文档、详细设计文档、测试文档、使用手册都是你要最先搞到手的。如果你是为了学习那么尽量收集和你的学习有关的资料，比如你想学习Linux的文件系统的代码，那最好要找到linux的使用手册、以及文件系统设计的方法、数据结构的说明。(这些资料在书店里都可以找到)。 材料的种类分为几种类型1.基础资料。比如你阅读turbo c2的源代码你要有turbo c2的函数手册，使用手册等专业书籍，msc 6.0或者Java 的话不但要有函数手册，还要有类库函数手册。这些资料都是你的基础资料。另外你要有一些关于uml的资料可以作为查询手册也是一个不错的选择。 2.和程序相关的专业资料。 每一个程序都是和相关行业相关的。比如我阅读过一个关于气象分析方面的代码，因为里边用到了一个复杂的数据转换公式，所以不得不把自己的大学时候课本 找出来来复习一下高等数学的内容。如果你想阅读linux的文件管理的代码，那么找一本讲解linux文件系统的书对你的帮助会很大。 3.相关项目的文档资料 这一部分的资料分为两种，一个相关行业的资料，比如你要阅读一个税务系统的代码那么有一些财务/税务系统的专业资料和国家的相关的法律、法规的资料是 必不可少的。此外就是关于这个项目的需求分析报告、概要设计报告、详细设计报告，使用手册、测试报告等，尽量多收集对你以后的代码阅读是很重要的 知识准备 了解基础知识，不要上来就阅读代码，打好基础可以做到事半功倍的效果 留备份,构造可运行的环境 代码拿到手之后的第一件事情是先做备份，最好是刻在一个光盘上，在代码阅读的时候一点不动代码是很困难的一件事情，特别是你要做一些修改性或增强性维护的时候。而一旦做修改就可能发生问题，到时候要恢复是经常发生的事情，如果你不能很好的使用版本控制软件那么先留一个备份是一个最起码的要求了。 在做完备份之后最好给自己构造一个可运行的环境，当然可能会很麻烦，但可运行代码和不可运行的代码阅读起来难度会差很多的。所以多用一点时间搭建一个环境是很值得的，而且我们阅读代码主要是为了修改其中的问题或做移植操作。不能运行的代码除了可以学到一些技术以外，用处有限。 找开始的地方 做什么事情都要知道从那里开始，读程序也不例外。在C语言里,首先要找到main()函数，然后逐层去阅读，其他的程序无论是vb、delphi都要首先找到程序头，否则你是很难分析清楚程序的层次关系。 分层次阅读 在阅读代码的时候不要一头就扎下去，这样往往容易只见树木不见森林，阅读代码比较好的方法有一点象二叉树的广度优先的遍历。在程序主体一般会比较简 单，调用的函数会比较少，根据函数的名字以及层次关系一般可以确定每一个函数的大致用途，将你的理解作为注解写在这些函数的边上。当然很难一次就将全部注 解都写正确，有时候甚至可能是你猜测的结果，不过没有关系这些注解在阅读过程是不断修正的，直到你全部理解了代码为止。一般来说采用逐层阅读的方法可以是 你系统的理解保持在一个正确的方向上。避免一下子扎入到细节的问题上。在分层次阅读的时候要注意一个问题，就是将系统的函数和开发人员编写代码区分开。在 c, c++，java ,delphi中都有自己的系统函数，不要去阅读这些系统函数，除非你要学习他们的编程方法，否则只会浪费你的时间。将系统函数表示出来，注明它们的作用 即可，区分系统函数和自编函数有几个方法，一个是系统函数的编程风格一般会比较好，而自编的函数的编程风格一般比较会比较差。从变量名、行之间的缩进、注 解等方面一般可以分辨出来，另外一个是像ms c6++会在你编程的时候给你生成一大堆文件出来，其中有很多文件是你用不到了，可以根据文件名来区分一下时候是系统函数，最后如果你实在确定不了，那就 用开发系统的帮助系统去查一下函数名，对一下参数等来确定即可。 写注解 写注解是在阅读代码中最重要的一个步骤，在我们阅读的源代码一般来说是我们不熟悉的系统,阅读别人的代码一般会有几个问题：1、搞明白别人的编程思想不 是一件很容易的事情，即使你知道这段程序的思路的时候也是一样。2、阅读代码的时候代码量一般会比较大，如果不及时写注解往往会造成读明白了后边忘了前边的 现象。3、阅读代码的时候难免会出现理解错误，如果没有及时的写注解很难及时的发现这些错误。4、不写注解有时候你发现你很难确定一个函数你什么时候阅读过，它的功能是什么，经常会发生重复阅读、理解的现象。 好了，说一些写注解的基本方法：1、猜测的去写，刚开始阅读一个代码的时候，你很难一下子就确定所有的函数的功能，不妨采用采用猜测的方法去写注解，根据函数的名字、位置写一个大致的注解，当然一般会有错误，但你的注解实际是不断调整的，直到最后你理解了全部代码。2、按功能去写，别把注解写成语法说明书，千万别看到fopen就写打开文件，看到fread就写读数据，这样的注解一点用处都没有，而应该写“在此处开发参数配置文件(**.dat)”、“读出系统初始化参数……”这样才是有用的注解。3、在写注解的使用另外要注意的一个问题是分清楚系统自动生成的代码和用户自己开发的代码，一般来说没有必要写系统自动生成的代码。象delphi的代码，我们往往要自己编写一些自己的代码段，还要对一些系统自动生成的代码段进行修改，这些代码在阅读过程是要写注解的，但有一些没有修改过的自动生成的代码就没有必要写注解了。4、在主要代码段要写较为详细的注解。有一些函数或类在程序中起关键的作用，那么要写比较详细的注解。这样对你理解代码有很大的帮助。5、对你理解起来比较困难的地方要写详细的注解，在这些地方往往会有一些编程的技巧。不理解这些编程技巧对你以后的理解或移植会有问题。6、写中文注解。如果你的英文足够的好，不用看这条了，但很多的人英文实在不怎么样，那就写中文注解吧，我们写注解是为了加快自己的理解速度。中文在大多数的时候比英文更适应中国人。与其写一些谁也看不懂的英文注解还不如不写。 重复阅读 一次就可以将所有的代码都阅读明白的人是没有的。至少我还没有遇到过。反复的去阅读同一段代码有助于对代码的理解。一般来说，在第一次阅读代码的时候 你可以跳过很多一时不明白的代码段，只写一些简单的注解，在以后的重复阅读过程中用，你对代码的理解会比上一次理解的更深刻，这样你可以修改那些注解错误的地方和上一次没有理解的地方。一般来说，对代码阅读3，4次基本可以理解代码的含义和作用。 运行并修改代码 如果你的代码是可运行的，那么先让它运行起来，用单步跟踪的方法来阅读代码，会提高你的代码速度。代码通过看中间变量了解代码的含义,而且对以后的修改会提供很大的帮助。 用自己的代码代替原有代码，看效果，但在之前要保留源代码。 600行的一个函数，阅读起来很困难，编程的人不是一个好的习惯。在阅读这个代码的时候将代码进行修改，变成了14个函数。每一个大约是40-50行左右。]]></content>
      <categories>
        <category>程序员生涯</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于CC3200实现WiFi Direct]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%9F%BA%E4%BA%8ECC3200%E5%AE%9E%E7%8E%B0WiFi%20Direct%2F</url>
    <content type="text"><![CDATA[遇到的问题与解决没接触过这类板子，有点陌生，不要紧，一步一步来。问题一：1.烧写了官方的SDK，按照提示，通过WiFi直连连接到了手机，但是失败概率很高，使用华为P10和魅蓝5连接不上，换用华为Nova2可以较为轻松的连上，暂时不知道是什么原因。2.在网上下载了几个APP：serial WiFi，WiFi TCP/UDP，可以连接到cc3200，但是无法数据通信。想知道是否需要TI官方相关的配套APP才可以。 解决一：下载了个APP“magic iperf”,好像是有了点作用，串口打印出已经收到TCP数据，然而没有打印出接收到的数据啊。 问题二：修改了程序，输出了接收缓冲区，但是输出的内容让人摸不着头脑。怎么看都不像是正常的数据包。现在最大的问题，应该怎样通过手机给模块发送TCP数据，并且通过串口打印输出到电脑上。代码里面找不到相关的内容，只有socket的创建，绑定端口等操作，在一个叫“BsdTcpServer”的函数里。这个函数，跟一般的建立一个TCP sever的基本思路大同小异，那么讲道理，TCP的接收数据的接口应该就是“sl_Recv”此类的函数，难道这个函数的参数“uBuf.BsdBuf”不是用于存放TCP数据包的吗？现在大致的思路应该是，使用串口中断，将接收到的数据，通过TCP的这个接口函数，发送到移动终端，就好了吧。 解决二：问题解决了，其实一直都是通的，但是这个官方的demo并没有将接收到的数据打印出来，仅仅是做了一个接收判断（即接收到数据后就亮一盏灯，然后打印出接收成功的字样）。另外，想要向手机端发送数据需要调用”sl_Send”函数，使用方式与“ sl_Recv ”类似。 问题三：现在的现象有点奇怪，两个情况下WiFi模块会无法连接：1.将开关拨到与WiFi模块相连，插上dongle，WiFi无法连接。另外，此时将开关拨到另一边，也不能连接WiFi。只有单独将WiFi模块复位才行。2.在连接上之后，发送AT+NRB，会导致WiFi断开，并再无法连接。解决办法同上，也是要将WiFi模块复位才行。根据以上现象来看，似乎是WiFi跟NB模组连接的串口导致。但是什么样的串口问题会导致这种情况呢？ 解决三：以上出现的现象原来是因为跟WiFi相连的另一路串口没有配置导致的，与NB模块LOGVIEW口相连的UART0串口，会在NB模块启动的时候收到log数据，导致WiFi模块卡死。为什么会卡死，我还不太明白，为什么没有配置的串口收到数据会导致程序卡死。 导致模块复位的原因知道了，是程序里的一个复位Pin脚占用了UART0的串口。 问题四：虽然配置好了两路的串口，但是发现，在收发AT命令的时候，两路串口好像会有干扰，导致收到的数据是乱码。之所以会这么觉得，是以为屏蔽了另一路串口问题就解决了。UART0的配置如下：1.引脚配置 123456789void PinMuxConfig(void)&#123; // Enable Peripheral Clocks MAP_PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK); MAP_PinTypeUART(PIN_03, PIN_MODE_7);//UART0 MAP_PinTypeUART(PIN_04, PIN_MODE_7);&#125; 2.串口属性配置 123456789101112131415void LOGVIEWComPort_Init_921600(void)&#123; MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8); MAP_UARTFIFOEnable(COM_P0); MAP_UARTFlowControlSet(COM_P0, UART_FLOWCONTROL_NONE); MAP_UARTConfigSetExpClk(COM_P0,MAP_PRCMPeripheralClockGet(COM_P0_PERIPH), 921600, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE)); MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler); MAP_IntPrioritySet(INT_UARTA0,INT_PRIORITY_LVL_0); MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX); &#125; 待解决四：进一步尝试，发现是这几句话会导致串口干扰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102 MAP_UARTFIFOLevelSet(COM_P0, UART_FIFO_TX7_8, UART_FIFO_RX7_8); MAP_UARTFIFOEnable(COM_P0); MAP_UARTIntRegister(COM_P0,COM_P0_RX_IRQHandler); MAP_UARTIntEnable(COM_P0,UART_INT_RT|UART_INT_RX);``` 解决四：问题原因是没有处理中断接收的数据，导致的干扰，配置好中断的处理函数之后就没有这样的问题了，不是以上这几条语句导致的。问题五：socket的数据流程整理了一下，数据结构挺庞大，好在还算清晰。简单的流程如下图：![] (https://app.yinxiang.com/shard/s62/res/14408816-1d63-434e-9576-39a18458d2c2)然后，数据是怎样从串口传到socket的呢？貌似是通过全局的队列，就是下面的这个函数，在UART的接收中断中执行``` bashvoid uart_get_char(char c)&#123; char flag = 0; portBASE_TYPE xHigherPriorityTaskWoken; uart_timer_stop(); lps_event_timer = 0; if (len_queue(&amp;g_p_uart_buf-&gt;queue) == UART_FRAME_MAX_LEN - 1) &#123; flag = 1; &#125;//队列满的情况计数，这部分代码可以复用 else if (full_quene(&amp;g_p_uart_buf-&gt;queue)) &#123; uart_bug_count++; //计数用来测试串口数据满的情况 Report("full_quene\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "full_quene\r\n"); if (g_p_uart_buf-&gt;lostNew) //丢弃最新的数据 &#123; g_uart_to_sock_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); return; &#125; else &#123; g_p_uart_buf-&gt;queue.rear = (g_p_uart_buf-&gt;queue.rear + 1) % QUEUE_SIZE; &#125; &#125; if (g_p_uart_buf-&gt;tmodeState == TMODE_CMD) &#123; if (c == '\n') //有些命令以\r\n结束 &#123; return; &#125; &#125; // 这里把串口收的数据放到这里 en_queue(&amp;g_p_uart_buf-&gt;queue, c); if (flag) &#123; g_uart_to_sock_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); &#125; else &#123; if (g_p_uart_buf-&gt;tmodeState == TMODE_CMD) &#123; if (g_p_uart_buf-&gt;echo == ECHO_ON) &#123; if('\r' != c) &#123; uart_output_byte(COM_P1, c); &#125; &#125; if (c == '\b') &#123; de_queue_font(&amp;g_p_uart_buf-&gt;queue); // delete '\b' de_queue_font(&amp;g_p_uart_buf-&gt;queue); // delete 'previous' uart_output_byte(COM_P1, ' '); uart_output_byte(COM_P1, '\b'); &#125; if (c == '\r') &#123; g_uart_to_at_cnt++; portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); &#125; &#125; else &#123; uart_timer_start(); &#125; &#125;&#125; 在以上存储数据的操作之后，将队列中的数据存到socket的数组中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void uart_recv_task(void *argc)&#123; uartParaStruct *pUartPara = (uartParaStruct *)argc; threadParaStruct *pThreadPara = pUartPara-&gt;para; uartBuf_typeDef *pBuf = l_v_uart_buf; char *pBufAt = NULL; unsigned short pos; int i; char existSock; while (!pThreadPara-&gt;threadCompleted) &#123; if ((l_uart_to_sock_cnt &gt; 0)) &#123; if (l_uart_to_sock_cnt &gt; 3) &#123; l_uart_to_sock_cnt = 3; &#125; pos = pBuf-&gt;queue.font; // 从串口buffer中取出数据 // 若无网络task，可以使用串口接受callback // 故每次直接从队列中取出数据，且tempbuf清楚 pBuf-&gt;tempBufLen = 0; memset(pBuf-&gt;tempBuf, 0, sizeof(pBuf-&gt;tempBuf)); do &#123; if (empty_quene(&amp;pBuf-&gt;queue)) &#123; l_uart_to_sock_cnt = 0; uart_debug("The uart queue is empty,need check code\n"); break; &#125; if (pBuf-&gt;tempBufLen &gt;= UART_FRAME_MAX_LEN) &#123; break; &#125; de_queue(&amp;pBuf-&gt;queue, &amp;pBuf-&gt;tempBuf[pBuf-&gt;tempBufLen]); pBuf-&gt;tempBufLen++; &#125; while (pos != pBuf-&gt;queue.rear); if (pBuf-&gt;tempBufLen &gt; 0) &#123; //uart callback if (pBuf-&gt;recv_callback) &#123; pBuf-&gt;tempBufLen = pBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_REDAY, (void *)pBuf, pBuf-&gt;tempBuf, pBuf-&gt;tempBufLen); &#125; //still have data,send quene to net task if (pBuf-&gt;tempBufLen &gt; 0) &#123; existSock = 0; if (g_sock_used[1] == TRUE) //当前sock建立 &#123; pBuf-&gt;sockSendLen[1] = pBuf-&gt;tempBufLen; existSock = 1; &#125; if (existSock) &#123; msleep(_DELAY_SWITCH_CONTEXT_MS); // 任务挂起，让给高优先级的sock &#125; while (1) &#123; existSock = 0; if ((g_sock_used[1] == TRUE) &amp;&amp; (g_sock_tcp[1] == TRUE)) &#123; if (pBuf-&gt;sockSendLen[1] &gt; 0) // 1 &#123; existSock = 1; &#125; &#125; if (existSock) &#123; msleep(_DELAY_FOR_WAIT_SOCK); &#125; else &#123; break; &#125; &#125; l_uart_to_sock_cnt--; &#125; else &#123; l_uart_to_sock_cnt--; &#125; &#125; &#125; else &#123; msleep(30); &#125; &#125;&#125; 最后，在socket的任务中会检测是否有数据存在，有的话就通过接口函数发送到网络 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//如果接收到了数据 if (g_p_uart_buf != NULL) &#123; if (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT) &#123; int send_len = g_p_uart_buf-&gt;sockSendLen[id]; //socka_debug("uart recv data\r\n"); //socka_debug("id=%d\r\n", id); start_time = xTaskGetTickCount(); // 获取ejoin 开始时间 //if(strlen(g_p_uart_buf-&gt;tempBuf)) ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0); first_time = xTaskGetTickCount(); LSD_Debug(LSD_DEBUG_LEVEL_3, "(%d,%u)\r\n", first_time-start_time, start_time); if ((ret &lt; 0) || (ret == 0)) &#123; socka_debug("socka send error\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "socka send error\r\n"); close(sock_fd); sock_fd = -1; pThreadPara-&gt;threadCompleted = TRUE; break; &#125; else if (send_len != ret) //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了 &#123; //网络未正常断开的时候，不能用send检测到 //这里发送失败就选择重新发送，接收的select中会检测到断网 //socka_debug("sock(%d) send fail\r\n", id); LSD_Debug(LSD_DEBUG_LEVEL_3, "sock(%d) send fail\r\n", id); if (reSendTimers++ &gt; NET_RECONNECT_TIMES) // 丢弃数据 &#123; //reSendTimers = reSendTimers; g_p_uart_buf-&gt;sockSendLen[id] = 0; &#125; else &#123; msleep(20); continue; &#125; &#125; needSleep = 0; reSendTimers = 0; g_p_uart_buf-&gt;sockSendLen[id] = 0; if(NULL != pNetBuf-&gt;recv_callback) // 150423 &#123; pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0); &#125; &#125; else &#123; // socka_debug("uart not recvd, wait...\r\n"); osi_Sleep(10); &#125; &#125;//如果接收到了数据 if (g_p_uart_buf != NULL) &#123; if (g_p_uart_buf-&gt;sockSendLen[id] &gt; 0 &amp;&amp; g_p_uart_buf-&gt;tmodeState == TMODE_THROUGHOUT) &#123; int send_len = g_p_uart_buf-&gt;sockSendLen[id]; //socka_debug("uart recv data\r\n"); //socka_debug("id=%d\r\n", id); start_time = xTaskGetTickCount(); // 获取ejoin 开始时间 //if(strlen(g_p_uart_buf-&gt;tempBuf)) ret = send(sock_fd, g_p_uart_buf-&gt;tempBuf, send_len, 0); first_time = xTaskGetTickCount(); LSD_Debug(LSD_DEBUG_LEVEL_3, "(%d,%u)\r\n", first_time-start_time, start_time); if ((ret &lt; 0) || (ret == 0)) &#123; socka_debug("socka send error\r\n"); LSD_Debug(LSD_DEBUG_LEVEL_3, "socka send error\r\n"); close(sock_fd); sock_fd = -1; pThreadPara-&gt;threadCompleted = TRUE; break; &#125; else if (send_len != ret) //由于没有互斥，只是依靠优先级，这句话其实挺危险的，长度可能在串口任务被改了 &#123; //网络未正常断开的时候，不能用send检测到 //这里发送失败就选择重新发送，接收的select中会检测到断网 //socka_debug("sock(%d) send fail\r\n", id); LSD_Debug(LSD_DEBUG_LEVEL_3, "sock(%d) send fail\r\n", id); if (reSendTimers++ &gt; NET_RECONNECT_TIMES) // 丢弃数据 &#123; //reSendTimers = reSendTimers; g_p_uart_buf-&gt;sockSendLen[id] = 0; &#125; else &#123; msleep(20); continue; &#125; &#125; needSleep = 0; reSendTimers = 0; g_p_uart_buf-&gt;sockSendLen[id] = 0; if(NULL != pNetBuf-&gt;recv_callback) // 150423 &#123; pNetBuf-&gt;recv_callback(LSDNET_E_SOCKET_DATA_SENDOK, &amp;id, NULL, 0); &#125; &#125; else &#123; // socka_debug("uart not recvd, wait...\r\n"); osi_Sleep(10); &#125; &#125; 现在遇到的麻烦是，开启sockB的时候，会导致堆栈溢出。 很好，堆栈溢出的问题解决了，原因是任务分配的内存大小不够，sockB的任务。 然而，新的问题又出现了，使用sockB无法连接。 最新问题，当数据大于等于512个字节时，队列的缓冲区就满了，很奇怪，明明分配了0x1600的空间，却用不到那么空间。 解决五： 上述问题都解决了，但实际上还遗留着一个问题，就是使用socketB作为lowview的数据通道时，串口中断的队列会溢出。现在的做法是，将socketB换成了AT命令的数据通道。问题得以规避。原因却没有找到，大概是socketB发送数据时出队的设计这边有些问题，支撑不了这么快的数据。 问题六： AT串口出现断包的现象，想想是什么原因吧，可是NB模块又是返回正确的数据长度以及OK，然而服务器那边却收不到断了的数据包。这是为什么？明天早上先把串口换一下试试。 解决六： 接收断包的现象可能跟WiFi模块的信号有关，使用手机做热点的时候并不会有这种现象，并且，这现象只发生在模块刚启动的一会儿，过一会就不再有这种情况。]]></content>
      <categories>
        <category>CC32xx系列开发</category>
      </categories>
      <tags>
        <tag>CC3200</tag>
        <tag>单片机</tag>
        <tag>WiFi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数函数用法]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[exampletypedef char* va_list;//用于声明一个指向参数列表的字符型指针变量void va_start(va_list ap,prev_param);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的第一个参数，通常用于指定可变参数列表中参数的个数void va_arg(va_list ap,type);//第一个参数为指向可变参数字符指针变量，第二个参数是可变参数的数据类型void va_end(va_list ap);//将存放可变参数字符串的变量清空（赋值为NULL） 123456789101112131415161718int sum(int count,...)//计算和&#123; int sum = 0; int i; va_list ap; va_start(ap,count); for(i=0;i&lt;count;++i) &#123; sum+=va_arg(ap,int); &#125; va_end(ap); return sum;&#125;int main()&#123; printf("%d\r\n",sum(3,1,2,3));&#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于回调函数的理解]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[example实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。 实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。 populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。 12345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; // 回调函数 void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) &#123; for (size_t i=0; i&lt;arraySize; i++) array[i] = getNextValue(); &#125; // 获取随机值 int getNextRandomValue(void) &#123; return rand(); &#125; int main(void) &#123; int myarray[10];//此处getNextValue指向 getNextRandomValue函数的地址，起到调用作用 populate_array(myarray, 10, getNextRandomValue); for(int i = 0; i &lt; 10; i++) &#123; printf("%d ", myarray[i]); &#125; printf("\n"); return 0; &#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《调试九法》读书笔记]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8A%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[制造失败如果做了所有尝试之后问题仍然间歇性发生制造失败的目的有三个：1.观察错误2.查找线索3.确认是否已修复记住，问题是美哦与自己的思维的，失败肯定有原因，你一定能够找到它。 仔细观察失败如果他不是每次都发生，那么就必须忽略掉不发生的时候，而在它每次发生时观察它。关键是在每次运行的时候捕捉相关信息，以便在发生失败之后查看这些数据。方法就是让系统在运行的时候尽可能多地输出信息，并把它们记录到“调试日志”文件中。 不要盲目相信统计数据制造失败的第二个目的是获得问题发生的线索。当发生一个间歇性问题时，你可以注意那些看起来与问题有关的操作模式。这种思路是没有问题的，但不要被表面现象所误导。如果失败是随机发生的，你可能无法收集到足够多地统计样本来作出判断，例如，用左手点击按钮与用右手点击按钮是否有着很大的区别。在很多时候，巧合会使你误认为莫衷条件比其他条件更可能引发问题。然后你就会开始仔细研究“这两种条件之间有什么区别”，由于你找错了对象，这将会浪费大量时间。这并不意味着你所看到的这些巧合的区别与问题不存在任何联系。但是，如果它们没有直接的影响，那么它们与问题的联系将会隐藏在其他随机因素背后，这时通过查看这些区别来找到原因的机会是非常渺茫的。当你捕获到足够多的信息时，就可以确定哪些因素总是与bug有关，或者哪些因素从来都与bug无关。在查找问题根源的时候，这些因素是需要重点关注的。 是已修复bug，还是仅仅由于运气好，它不再发生了如果失败是随机发生的，那么要想证明bug是否已被修复就会困难得多，这一点是毫无疑问的。如果在测试的时候，每10次发生1次失败，在你“修复”它之后，变成了每30次发生1次，而你在测试28次之后终止了测试，这时你认为问题已修复，但实际上并没有。最好的办法是找到一个总是与失败有关的事件序列。即使这个序列本身就是间歇性的，但当它发生时，100%会发生失败。然后，当你认为已修复bug时，就可以运行测试，直到这个序列出现，如果没有发生失败，那么你确实已修复了bug。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[va_start和va_end使用详解]]></title>
    <url>%2F2019%2F03%2F05%2Fva_start%E5%92%8Cva_end%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言1.在C中，当我们无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表 void foo(…);void foo(parm_list,…);这种方式和我们以前认识的不大一样，但我们要记住这是C中一种传参的形式，在后面我们就会用到它。 2.函数参数的传递原理 函数参数是以数据结构:栈的形式存取,从右至左入栈。 首先是参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址，举个例子如下：void func(int x, float y, char z); 那么，调用函数的时候，实参 char z 先进栈，然后是 float y，最后是 int x，因此在内存中变量的存放次序是 x-&gt;y-&gt;z，因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过指针移位运算，则总可以顺藤摸瓜找到其他的输入变量。 下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：typedef char va_list;void va_start ( va_list ap, prev_param ); / ANSI version */type va_arg ( va_list ap, type );void va_end ( va_list ap );va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)； 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数； 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置； 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。 example123456789101112131415161718192021222324#include &lt;iostream.h&gt; void fun(int a, ...) &#123; int *temp = &amp;a; temp++; for (int i = 0; i &lt; a; ++i) &#123; cout &lt;&lt; *temp &lt;&lt; endl; temp++; &#125; &#125;int main() &#123; int a = 1; int b = 2; int c = 3; int d = 4; fun(4, a, b, c, d); system("pause"); return 0; &#125; Output:: 1 2 3 4 3:获取省略号指定的参数 在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。像这段代码： 12345678910111213141516171819202122232425262728293031323334353637void TestFun(char* pszDest, int DestLen, const char* pszFormat, ...) &#123; va_list args; va_start(args, pszFormat); //一定要“...”之前的那个参数_vsnprintf(pszDest, DestLen, pszFormat, args); va_end(args); &#125; 4.演示如何使用参数个数可变的函数，采用ANSI标准形式 #include 〈stdio.h〉 #include 〈string.h〉 #include 〈stdarg.h〉 /*函数原型声明，至少需要一个确定的参数，注意括号内的省略号*/ int demo( char, ... ); void main( void ) &#123; demo("DEMO", "This", "is", "a", "demo!", ""); &#125; /*ANSI标准形式的声明方式，括号内的省略号表示可选参数*/ int demo( char msg, ... ) &#123; /*定义保存函数参数的结构*/ va_list argp; int argno = 0; char para; /*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/ va_start( argp, msg ); while (1) &#123; para = va_arg( argp, char); if ( strcmp( para, "") == 0 ) break; printf("Parameter #%d is: %s\n", argno, para); argno++; &#125; va_end( argp ); /*将argp置为NULL*/return 0; &#125;]]></content>
      <categories>
        <category>当时我所不知道的C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCons的使用]]></title>
    <url>%2F2019%2F03%2F05%2FSCons%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、概述SCons是一个Python写的自动化构建工具，和GNU make相比优点明显：1.移植性：Python能运行的地方，就能运行SCons2.扩展性：理论上SCons只是提供了Python的类，SCons使用者可以在这个类的基础上做所有Python能做的事情。比如想把一个已经使用了Makefile大型工程切换到SCons，就可以保留原来的Makefile，并使用Python解析Makefile中的编译选项、源/目标文件等，作为参数传递给SCons,完成编译。3、智能：SCons继承了autoconf/automake的功能，自动解析系统的include路径、typedef等；“以全局的观点来看所有的依赖关系” 二、SCons文件SCons中可能出现的文件： SConstruct,Sconstruct,sconstruct,SConscriptSCons将在当前目录以下次序:SConstruct,Sconstruct,sconstruct来搜索配置文件，从读取的第一个文件中读取相关配置。在配置文件SConstruct中可以使用函数SConscript()函数来定附属的配置文件。按惯例，这些附属配置文件被命名为“SConscript”,当然也可以使用任意其它名字。 三、SCons的命令行参数scons:执行SConstruct中脚本scons -c:cleanscons -Q:只显示编译信息，去除多余的打印信息scons -Q–implicit-cache hello:保存依赖关系–implicit-deps-changed:强制更新依赖关系–implicit-deps-unchanged:强制使用原先的依赖关系，即使已经改变 四、SConstruct提供的方法1、Program:生成可执行文件 Program(‘hello.c’) 编译hello.c可执行文件，根据系统自动生成(hello.exe on Windows; hello on POSIX) Program(‘hello’,’hello.c’) 指定Output文件名(hello.exe on Windows; hello on POSIX) Program([‘hello.c’, ‘file1.c’, ‘file2.c’]) 编译多个文件，Output文件名以第一个文件命名 Program(source = “hello.c”,target = “hello”) Program(target = “hello” , source = “hello.c”) Program(‘hello’, Split(‘hello.c file1.c file2.c’)) 编译多个文件 Program(Glob(&quot;*.c&quot;)) src = [&quot;hello.c&quot;,&quot;foo.c&quot;];Program(src) 2、Object：生成目标文件 Object(&apos;hello.c&apos;) 编译hello.c目标文件，根据系统自动生成(hello.obj on Windows; hello.o on POSIX) 3、Library：生成静态/动态库文件 Library(&apos;foo&apos;, [&apos;f1.c&apos;, &apos;f2.c&apos;, &apos;f3.c&apos;]) 编译library SharedLibrary(&apos;foo&apos;, [&apos;f1.c&apos;, &apos;f2.c&apos;, &apos;f3.c&apos;]) 编译 shared library StaticLibrary(&apos;bar&apos;, [&apos;f4.c&apos;, &apos;f5.c&apos;, &apos;f6.c&apos;]) 编译 static library 库的使用： Program(&apos;prog.c&apos;, LIBS=[&apos;foo&apos;, &apos;bar&apos;], LIBPATH=&apos;.&apos;) 连接库，不需加后缀或是前缀 4、SourceSignatures：判断源文件是否修改 SourceSignatures(‘MD5’) 根据内容是否改变，默认方式 SourceSignatures(‘timestamp’) 根据修改时间 5、TargetSignatures：判断目标文件是否改变 TargetSignatures(‘build’) 根据编译结果 TargetSignatures(‘content’) 根据文件内容，如果只是加了句注释，将不会被重新编译 6、Ignore：忽略依赖关系 Ignore(hello, &apos;hello.h&apos;) 忽略某个依赖关系 7、Depends：明确依赖关系 Depends(hello, &apos;other_file&apos;) 明确依赖关系 8、SConscript：scons的配置文件。 源文件的目录结构如下： src： | SConstruct | test.cpp | mA(目录)： | SConscript | func.cpp 其中test.cpp为主文件，中调用func.cpp中定义的函数 SConstruct内容如下： 12obj = Object(Glob("*.cpp"))Return("obj") 上例中，在主目录中执行 scons就可以编译整个”工程”。SConstruct编译主目录中的test.cpp，并通过SConscript编译mA目录下的源文件，并最终生成可执行文件；SConscript用于编译mA中的func.cpp并把生成的func.o传递给主目录的SConstruct。 10.env：环境变量 环境变量用于设置在编译过程中的各种参数，可以用下面的SConstruct打印环境变量的所有信息(实际上env就是一个python字典) 可以使用如下的SConstruct查看环境变量的内容：123456env = Environment()dict = env.Dictionary()keys = dict.keys()keys.sort()for key in keys: print "construction variable = '%s', value = '%s'" % (key, dict[key]) 环境变量的使用： env = Environment() #创建默认的环境变量，默认scons会按编译器的默认选项来进行编译 import os env = Environment(CC = ‘gcc’,CCFLAGS = ‘-O2’) #创建并设置环境 变量 env.Program(‘foo.c’) 环境变量的复制： env = Environment(CC = &apos;gcc&apos;) opt = env.Clone(CCFLAGS = &apos;-O2&apos;) dbg = env.Clone(CCFLAGS = &apos;-g&apos;) 环境变量的替换： env = Environment(CCFLAGS = &apos;-DDEFINE1&apos;) env.Replace(CCFLAGS = &apos;-DDEFINE2&apos;) env.Program(&apos;foo.c&apos;) 环境变量的输入输出：用于统一多目录源文件的编译选项，如： src： | SConstruct | libstlport.a | test.cpp | include(目录)： | foo.h | mA(目录)： | SConscript | func.cpp test.cpp和mA/func.cpp都引用了include/foo.h,test.cpp调用了mA/func.cpp的功能函数,其中include/foo.h中定义了一个包含string类型的类。 SConstruct如下： 1234567891011env = Environment()flags = env.ParseFlags(['-pthread -I/usr/include/stlport ',' -L .'])env.MergeFlags(class_flags)subobj = SConscript(['mA/SConscript'])obj = subobj + env.Object(Glob("*.cpp"))env.Program("test",list(obj),LIBS = ['libstlport.a'])``` mA/SConscrip如下: ```pythonobj = Object(Glob("*.cpp"))Return("obj") 不出意外的话上边的工程编译可以通过，但是运行的时候会Aborted。因为test.cpp,mA/func.cpp都使用了包含string类型的那个类，但是由于编译环境的不同，test.cpp认为string变量的大小是24字节, mA/func.cpp认为string变量的大小是4个字节(libstlport.a捣的鬼)。 解决问题的办法就是环境变量输出，修改SConstruct和mA/SConscript如下： SConstruct： 1234567env = Environment()flags = env.ParseFlags(['-pthread -I/usr/include/stlport ',' -L .'])env.MergeFlags(class_flags)Export('env')subobj = SConscript(['mA/SConscript'],exports = 'env')obj = subobj + env.Object(Glob("*.cpp"))env.Program("test",list(obj),LIBS = ['libstlport.a']) mA/SConscript:123Import('env')obj = env.Object(Glob("*.cpp"))Return("obj")]]></content>
      <categories>
        <category>Hi2115开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS3DH传感器用法]]></title>
    <url>%2F2019%2F03%2F05%2FLIS3DH%E4%BC%A0%E6%84%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[中断功能INT1中断Lis3dh提供了一个INT1 (inertial interrupt)的信号处理中断，它包括下面三个寄存器。 INT1_CFG(30h) INT1_THS(32h) INT1_DURATION(33h)简单的说这个中断的功能就是检测sensor三个轴的加速度的值大于或小于设定阀值的信号，在寄存器INT_CFG里，你可以选择哪个轴的值大于或小于这个阀值，这里可以组合你要检测的轴，亦即方向（大于或小于）。INT1_THS就是设定的阀值，这个值是一个绝对的值，假如设定这个值是200mg, 然后enable XLIE，这意味你要检测到X轴的值小于200mg，大于-200mg的信号。如果enable XHIE, 这表示你要检测到x轴大于200mg，或小于-200mg的信号，INT1_DURATION 定义检测到设定信号后持续的时间，当达到这个时间后就可以触发中断，当然这里还要设置下如下寄存器的I1_AOI1 把实际的中断信号enable到硬件的中断管脚1。信号检测的模型 参数设置 THS设置 首先阀值的设置是和sensor设定的测量范围是相关的，如下表，如sensor的测量范围设为2g时，阀值寄存器的每个逻辑数对应的是16mg。举个例子，我们要设定一个256mg的wakeup的阀值，我们就应该在INT1_THS写入16。因为16mg*16=256mg Duration设置 Duration时间的设置是与sensor的ODR( output datarate )相关的，如下表，所以duration= 1/ODR * LSB，LSB写入寄存器的值。 基于int1实现的功能 Wake up 当传感器静止放在水平面时，x轴和y轴是一个接近0mg的值，这时可以设置x轴和y轴中任意一个值大于设定的阀值，当触发中断时，表明这个器件姿态发生了变化，导致x轴和y轴大于阀值，从而唤醒主控。但有个问题是当器件不是放在水平面时怎么办，x和y 可能是一个任意的-1g到1g 的值，如何设定这个阀值，还有在水平的情况下，又如何检测z 轴，因为此时z轴是个1 g或-1g的值。最好的情况是当器件静止但在任意姿态时，最好三个轴的输出都接近0mg，我只要检测到任意一个轴大于一个小的阀值，就表明器件姿态发生了改变，相比前面只检测x和y轴，这样灵敏度会大大提高。要达到这个目的就要用到highpass filter 功能。当设置了HPIS1后，highpass filter可以滤掉数据的直流分量，只要器件静止，任何一个轴的数据都是0mg，当器件姿态变化时，这个变化的量仍能体现在数据的输出上，所以可以检测相应变化。 Note: 这里的highpass filter 只作用在int1上，而不会影响sensor的数据输出 free fall 这个功能刚好是与wake up相反的，它是检测到三个轴都小于一个阀值，另一个不同的是触发条件是三个轴同时满足，和wakeup 任意一个轴触发是不同的，体现在寄存器INT1_CFG 的AOIbit , AOI 决定了这些信号是与关系还是或关系，显然对于wake up 是或的关系，对于freefall是与的关系。 6D 如下图，你可以看到器件的6个position, 6D功能就是检测当前是在那个或移动到哪个position的一种状态识别。这个功能要用到INT1的另一个source寄存器，实际上就是通过source寄存器来确定6D position。XH，YH，ZH，分别表示x，y，z轴在正方向大于或小于阀值的状态 XL，YL，ZL，分别表示x，y，z轴在负方向上大于或小于阀值的状态如下表source的组合对应的就是上图的6个positions。这里6d有两种工作模式，一个是movement识别，另一个是position识别。 Movement: 就是当物体从一个已知的或未知的方向转动到另一个已知的但不同原方向的方向，并且产生一个1/ODR( 数据输出平率)周期的中断。 Position: 当物体稳定在一个已知的方向，将产生一个持续的中断信号直到方向改变。 通过INT_CFG1的AO1，6D bit 配置这两种模。 Movement: AOI-6D = 01 Position: AOI-6D = 11 对于这六个面的识别，很关建的是阀值的设置，在相对静态的转动时，每个轴最大是1g 或-1g，考虑到sensor的offset，和一些其他的误差，所以阀值要适当小于1g，但不能太小，不能出现两个轴同时大于阀值的情况。]]></content>
      <categories>
        <category>传感器</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hi2115开发——ADC使用]]></title>
    <url>%2F2019%2F03%2F05%2FHi2115%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94ADC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Hi2115开发——ADC使用@(Hi2115开发) 与其他外设一样，海思的adc使用方式跟ST系列的差异甚大，但是集成度更高，用户使用起来总的来说是更方便了。当然，方便的前提是建立在有详细说明之上的。所以，还是排了很多坑。adc的驱动函数是在“driver”-&gt;”cmsis”-&gt;”adc”里。另外在“lib”-&gt;”aio_functions”文件夹中有海思封装的关于adc的一些函数。例如： /** * @brief Measures comparator outputs with adc in cal mode (inputs shorted), and adjusts trim registers. * AIO peripherals muxbus0 and ADC and VDD_CORE * @return AIO_FUNC_RET_OK for success else error */ AIO_FUNC_RET aio_func_trim_adc(void) { AIO_MANAGER_RET ret_val; AIO_FUNC_RET aio_func_ret = AIO_FUNC_RET_ERROR; AIO_RESOURCE resource_list[] = { AIO_RESOURCE_MUXBUS_0, AIO_RESOURCE_ADC, AIO_RESOURCE_VDD_CORE}; //TODO?? ret_val = aio_manager_claim_resource(resource_list, sizeof(resource_list)); if ( ret_val != AIO_MANAGER_RET_OK) { return aio_func_ret; } ret_val = aio_manager_connect_analog_resource_to_muxbus(AIO_RESOURCE_ADC, AIO_MUXBUS_0); if ( ret_val != AIO_MANAGER_RET_OK) { (void)aio_manager_free_resource(resource_list, sizeof(resource_list)); return aio_func_ret; } ret_val = aio_manager_connect_analog_resource_to_muxbus(AIO_RESOURCE_VDD_CORE, AIO_MUXBUS_0); if(ret_val != AIO_MANAGER_RET_OK) { (void)aio_manager_disconnect_analog_resource_from_muxbus(AIO_RESOURCE_ADC, AIO_MUXBUS_0); (void)aio_manager_free_resource(resource_list, sizeof(resource_list)); } adc_init(); aio_manager_vdd_core_enable(); adc_find_trim_values(); aio_manager_vdd_core_disable(); adc_deinit(); ret_val = aio_manager_disconnect_analog_resource_from_muxbus(AIO_RESOURCE_VDD_CORE, AIO_MUXBUS_0); if ( ret_val != AIO_MANAGER_RET_OK) { (void)aio_manager_disconnect_analog_resource_from_muxbus(AIO_RESOURCE_ADC, AIO_MUXBUS_0); (void)aio_manager_free_resource(resource_list, sizeof(resource_list)); return aio_func_ret; } ret_val = aio_manager_disconnect_analog_resource_from_muxbus(AIO_RESOURCE_ADC, AIO_MUXBUS_0); if ( ret_val != AIO_MANAGER_RET_OK) { (void)aio_manager_free_resource(resource_list, sizeof(resource_list)); return aio_func_ret; } ret_val = aio_manager_free_resource(resource_list, sizeof(resource_list)); if (ret_val == AIO_MANAGER_RET_OK) { aio_func_ret = AIO_FUNC_RET_OK; } return aio_func_ret; } 看注释的意思是，这个函数是用来校准模式下的adc测量比较器输出（输入短路），并调整调整寄存器。再看下面这个函数： /** * @brief read the analogue voltage present on the AIO&lt;0&gt; or AIO&lt;1&gt; pins, displayed in mv * @param voltage reading in millivolts * @param AIO&lt;n&gt; pin number, 0 or 1 * @return AIO_FUNC_RET_OK for success, error for any read failure reason */ AIO_FUNC_RET aio_func_read_aiopin(uint32 *voltage, uint8 aio_pin_number) { AIO_MANAGER_RET ret_val; AIO_FUNC_RET aio_func_ret = AIO_FUNC_RET_ERROR; AIO_RESOURCE resource_list0[] = { AIO_RESOURCE_MUXBUS_0, AIO_RESOURCE_AIO_PIN_0, AIO_RESOURCE_ADC}; AIO_RESOURCE resource_list1[] = { AIO_RESOURCE_MUXBUS_1, AIO_RESOURCE_AIO_PIN_1, AIO_RESOURCE_ADC}; AIO_RESOURCE *resource_list; uint8 resource_list_length; AIO_MUXBUS muxbus_to_use; uint32 local_voltage; // configure different resources depending on AIO 0 or 1 // for AIO&lt;0&gt; resource_list = &amp;resource_list0[0]; resource_list_length = sizeof(resource_list0)/sizeof(AIO_RESOURCE); muxbus_to_use = AIO_MUXBUS_0; if( aio_pin_number == 1) { // for AIO&lt;1&gt; resource_list = &amp;resource_list1[0]; resource_list_length = sizeof(resource_list1)/sizeof(AIO_RESOURCE); muxbus_to_use = AIO_MUXBUS_1; } ret_val = aio_manager_claim_resource(resource_list, resource_list_length); if ( ret_val != AIO_MANAGER_RET_OK) { return aio_func_ret; } // try to connect ADC to muxbus if( AIO_MANAGER_RET_OK != aio_manager_connect_analog_resource_to_muxbus(AIO_RESOURCE_ADC, muxbus_to_use) ) { // failed, free the resources, and report error (void)aio_manager_free_resource(resource_list, resource_list_length); aio_func_ret = AIO_FUNC_RET_ERROR; return aio_func_ret; } // try to connect AIO pin to muxbus if( AIO_MANAGER_RET_OK != aio_manager_connect_analog_resource_to_muxbus(resource_list[1], muxbus_to_use) ) { // failed, need to disconnect the ADC, then free the resources and report error (void)aio_manager_disconnect_analog_resource_from_muxbus(AIO_RESOURCE_ADC, muxbus_to_use); (void)aio_manager_free_resource(resource_list, resource_list_length); aio_func_ret = AIO_FUNC_RET_ERROR; return aio_func_ret; } adc_init(); (void)aio_pin_init((AIO_PIN)aio_pin_number); if (adc_read_mv(0, &amp;local_voltage) == ADC_RET_OK) { *voltage = local_voltage; aio_func_ret = AIO_FUNC_RET_OK; } else { *voltage = 0; aio_func_ret = AIO_FUNC_RET_ERROR; } (void)aio_pin_deinit((AIO_PIN)aio_pin_number); adc_deinit(); if ( aio_manager_disconnect_analog_resource_from_muxbus(AIO_RESOURCE_ADC, muxbus_to_use) != AIO_MANAGER_RET_OK) { aio_func_ret = AIO_FUNC_RET_ERROR; } if ( aio_manager_disconnect_analog_resource_from_muxbus(resource_list[1], muxbus_to_use) != AIO_MANAGER_RET_OK) { aio_func_ret = AIO_FUNC_RET_ERROR; } if (aio_manager_free_resource(resource_list, resource_list_length) != AIO_MANAGER_RET_OK) { aio_func_ret = AIO_FUNC_RET_ERROR; } return aio_func_ret; } 这个函数的作用是读取该引脚上的电压单位是mv的，如果是要提供给客户检测电池电量，估计直接用这个函数就好了。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>NB-IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoAP协议——格式详解]]></title>
    <url>%2F2019%2F03%2F05%2FCoAP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CoAP是受限制的应用协议(Constrained Application Protocol)的代名词。在当前由PC机组成的世界，交换是通过TCP和应用层协议HTTP实现的。但是对于小型设备而言，实现TCP和HTTP协议显然是一个过分的要求。为了让小设备可以接入，CoAP协议被设计出来。CoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。CoAP协议非常小巧，最小的包仅为4字节。 1.CoAP协议综述和其他TCP IP协议簇中的协议一样，CoAP协议总是以“头”的形式出现在负载之前，而负载和CoAP头之间使用单字节0xFF分离。学习CoAP协议最好的方法便是结合RFC文档，详细分析CoAP协议报文格式的每一部分，便是CoAP协议报文结构示意图。 2.CoAP协议报文结构示意图【Ver】 版本编号，指示CoAP协议的版本号。类似于HTTP 1.0 HTTP 1.1。版本编号占2位，取值为01B。 【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。 【TKL】CoAP标识符长度。CoAP协议中具有两种功能相似的标识符，一种为Message ID(报文编号)，一种为Token(标识符)。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。 【Code】功能码/响应码。Code在CoAP请求报文和响应报文中具有不同的表现形式，Code占一个字节，它被分成了两部分，前3位一部分，后5位一部分，为了方便描述它被写成了c.dd结构。其中0.XX表示CoAP请求的某种方法，而2.XX、4.XX或5.XX则表示CoAP响应的某种具体表现。 【Message ID】报文编号 【Token】标识符具体内容，通过TKL指定Token长度。 【Option】报文选项，通过报文选项可设定CoAP主机，CoAP URI，CoAP请求参数和负载媒体类型等等。 【1111 1111B】CoAP报文和具体负载之间的分隔符。 3.Code部分详解 Code部分被分成了两部分，为了便于阅读，Code被描述为c.dd形式。具体内容可参考RFC7252 #12.1.1 Method Codes 3.1 请求在CoAP请求中，Code被定义为CoAP请求方法，这些方法有GET、POST、PUT和DELETE，这些方法和HTTP协议非常相似。 【0.01】GET方法——用于获得某资源 【0.02】POST方法——用于创建某资源 【0.03】PUT方法——用于更新某资源 【0.04】DELETE方法——用于删除某资源 3.2 响应在CoAP响应中，Code被定义为CoAP响应码，类似于HTTP 200 OK等等。 【2.01】Created 【2.02】Deleted 【2.03】Valid 【2.04】Changed 【2.05】Content。类似于HTTP 200 OK 【4.00】Bad Request 请求错误，服务器无法处理。类似于HTTP 400。 【4.01】Unauthorized 没有范围权限。类似于HTTP 401。 【4.02】Bad Option 请求中包含错误选项。 【4.03】Forbidden 服务器拒绝请求。类似于HTTP 403。 【4.04】Not Found 服务器找不到资源。类似于HTTP 404。 【4.05】Method Not Allowed 非法请求方法。类似于HTTP 405。 【4.06】Not Acceptable 请求选项和服务器生成内容选项不一致。类似于HTTP 406。 【4.12】Precondition Failed 请求参数不足。类似于HTTP 412。 【4.15】Unsuppor Conten-Type 请求中的媒体类型不被支持。类似于HTTP 415。 【5.00】Internal Server Error 服务器内部错误。类似于HTTP 500。 【5.01】Not Implemented 服务器无法支持请求内容。类似于HTTP 501。 【5.02】Bad Gateway 服务器作为网关时，收到了一个错误的响应。类似于HTTP 502。 【5.03】Service Unavailable 服务器过载或者维护停机。类似于HTTP 503。 【5.04】Gateway Timeout 服务器作为网关时，执行请求时发生超时错误。类似于HTTP 504。 【5.05】Proxying Not Supported 服务器不支持代理功能。 4.Option部分详解CoAP支持多个Option，CoAP的Option的表示方法比较特殊，采用增量的方式描述，细节可参考RFC7252 #3.1 CoAP支持多个Option，CoAP的Option的表示方法比较特殊，采用增量的方式描述，细节可参考RFC7252 #3.1 一般情况下Option部分包含Option Delta、Option Length和Option Value三部分。 【Option Delta】表示Option的增量，当前的Option的具体编号等于之前所有Option Delta的总和。 【Option Length】表示Option Value的具体长度。 【Option Value】表示Option具体内容 CoAP中所有的Option都采用编号的方式，这些Option及编号的定义如下图所示。 在这些option中，Uri-Host、Uri-Port、Uri-Path和Uri-Query等和资源“位置”和参数有关。 【3】Uri-Host:CoAP主机名称，例如iot.eclipse.org 【7】Uri-Port:CoAP端口号，默认为5683 【11】Uri-Path:资源路由或路径，例如\temperature。资源路径采用UTF8字符串形式，长度不计第一个”\”。 【15】Uri-Query:访问资源参数，例如?value1=1&amp;value2=2，参数与参数之间使用“&amp;”分隔，Uri-Query和Uri-Path之间采用“?”分隔。 在这些option中，Content-Format和Accept用于表示CoAP负载的媒体格式 【12】Content-Format:指定CoAP复杂媒体类型，媒体类型采用整数描述，例如application/json对应整数50，application/octet-stream对应整数40。 【17】Accept: 指定CoAP响应复杂中的媒体类型，媒体类型的定义和Content-Format相同。 CoAP协议中支持多个Option，例如 第一个Option Delta=11，表示该Option表示Uri-Path(11) 第二个Option Delta=1，表示该Option=1+11，表示Content-Format(12) 第三个Option Delta=3，表示该Option=3+1+11，表示Uri-Query(15) CoAP采用这样的方式表示多个Option，而每种Option都可以在HTTP协议中找到对应项。 5.Content-Format描述CoAP支持多种媒体类型，具体可参考RFC7252 #12.3。从下图的信息可以发现，CoAP协议中关于媒体类型的定义比较简单，未来应该会根据实际情况扩展。 【text/plain】 编号为0，表示负载为字符串形式，默认为UTF8编码。 【application/link-format】编号为40，CoAP资源发现协议中追加定义，该媒体类型为CoAP协议特有。 【application/xml】编号为41，表示负载类型为XML格式。 【application/octet-stream】编号为42，表示负载类型为二进制格式。 【application/exi】编号为47，表示负载类型为“精简XML”格式。(翻译不一定准确) 另外，还有一种格式也北IANA认定，也会在CoAP协议中广泛使用那便是CBOR格式，该格式可理解为二进制JSON格式。 【applicaiton/cbor】编号为60。 6.示例该示例来自于RFC7252。 【流程描述】 CoAP客户端通过GET方法从Server端获得温度传感器数据，CoAP URI如下 coap://www.server.com/temperautre CoAP请求采用CON报文，Server接收到CON报文必须返回一个ACK报文。CoAP请求采用0.01 GET方法，若操作成功CoAP Server返回2.05 Content，相当于HTTP 200 OK。请求和响应的MID必须完全相同，此处为0x7d34。请求响应中的Token域为空。CoAP请求中包含Option，该Option的类型为Uri-Path，那么Option Delta的值为0+11=11，Option Value的值为字符串形式的“temperature”。CoAP返回中包含温度数据，使用字符串形式描述，具体值为”22.3”。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>CoAP</tag>
      </tags>
  </entry>
</search>
